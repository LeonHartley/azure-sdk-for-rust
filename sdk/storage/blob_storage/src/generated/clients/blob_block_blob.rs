// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::models::{AccessTier, BlobImmutabilityPolicyMode, BlockListType, BlockLookupList};
use azure_core::builders::ClientMethodOptionsBuilder;
use azure_core::{
    AsClientMethodOptions, ClientMethodOptions, Context, Method, Pipeline, Request, RequestContent,
    Response, Result, Url,
};
use time::OffsetDateTime;

pub struct BlobBlockBlob {
    pub(in crate::generated::clients) endpoint: Url,
    pub(in crate::generated::clients) pipeline: Pipeline,
}

impl BlobBlockBlob {
    /// The Commit Block List operation writes a blob by specifying the list of block IDs that make up the blob. In order to be
    /// written as part of a blob, a block must have been successfully written to the server in a prior Put Block operation. You
    /// can call Put Block List to update a blob by uploading only those blocks that have changed, then committing the new and
    /// existing blocks together. You can do this by specifying whether to commit a block from the committed block list or from
    /// the uncommitted block list, or to commit the most recently uploaded version of the block, whichever list it may belong
    /// to.
    pub async fn commit_block_list(
        &self,
        blocks: RequestContent<BlockLookupList>,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlockBlobCommitBlockListOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/?comp=blocklist/{containerName}/{blob}");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", transactional_content_md5);
        }
        request.insert_header("content-type", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(tier) = options.tier {
            request.insert_header("x-ms-access-tier", tier.to_string());
        }
        if let Some(blob_cache_control) = options.blob_cache_control {
            request.insert_header("x-ms-blob-cache-control", blob_cache_control);
        }
        if let Some(blob_content_disposition) = options.blob_content_disposition {
            request.insert_header("x-ms-blob-content-disposition", blob_content_disposition);
        }
        if let Some(blob_content_encoding) = options.blob_content_encoding {
            request.insert_header("x-ms-blob-content-encoding", blob_content_encoding);
        }
        if let Some(blob_content_language) = options.blob_content_language {
            request.insert_header("x-ms-blob-content-language", blob_content_language);
        }
        if let Some(blob_content_md5) = options.blob_content_md5 {
            request.insert_header("x-ms-blob-content-md5", blob_content_md5);
        }
        if let Some(blob_content_type) = options.blob_content_type {
            request.insert_header("x-ms-blob-content-type", blob_content_type);
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(transactional_content_crc64) = options.transactional_content_crc64 {
            request.insert_header("x-ms-content-crc64", transactional_content_crc64);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm);
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(immutability_policy_mode) = options.immutability_policy_mode {
            request.insert_header(
                "x-ms-immutability-policy-mode",
                immutability_policy_mode.to_string(),
            );
        }
        if let Some(immutability_policy_expiry) = options.immutability_policy_expiry {
            request.insert_header(
                "x-ms-immutability-policy-until-date",
                immutability_policy_expiry,
            );
        }
        if let Some(legal_hold) = options.legal_hold {
            request.insert_header("x-ms-legal-hold", legal_hold.to_string());
        }
        if let Some(blob_tags_string) = options.blob_tags_string {
            request.insert_header("x-ms-tags", blob_tags_string);
        }
        request.insert_header("x-ms-version", version.into());
        request.set_body(blocks);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Get Block List operation retrieves the list of blocks that have been uploaded as part of a block blob.
    pub async fn get_block_list(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        list_type: BlockListType,
        version: impl Into<String>,
        options: Option<BlobBlockBlobGetBlockListOptions<'_>>,
    ) -> Result<Response<BlockLookupList>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/?comp=blocklist/{containerName}/{blob}");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        url.query_pairs_mut()
            .append_pair("blocklisttype", &list_type.to_string());
        if let Some(snapshot) = options.snapshot {
            url.query_pairs_mut().append_pair("snapshot", &snapshot);
        }
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Put Blob from URL operation creates a new Block Blob where the contents of the blob are read from a given URL. This
    /// API is supported beginning with the 2020-04-08 version. Partial updates are not supported with Put Blob from URL; the
    /// content of an existing blob is overwritten with the content of the new blob. To perform partial updates to a block blobâ€™s
    /// contents using a source URL, use the Put Block from URL API in conjunction with Put Block List.
    pub async fn put_blob_from_url(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        content_length: i64,
        copy_source: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlockBlobPutBlobFromUrlOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}?BlockBlob&fromUrl");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-length", content_length.to_string());
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", transactional_content_md5);
        }
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(tier) = options.tier {
            request.insert_header("x-ms-access-tier", tier.to_string());
        }
        if let Some(blob_cache_control) = options.blob_cache_control {
            request.insert_header("x-ms-blob-cache-control", blob_cache_control);
        }
        if let Some(blob_content_disposition) = options.blob_content_disposition {
            request.insert_header("x-ms-blob-content-disposition", blob_content_disposition);
        }
        if let Some(blob_content_encoding) = options.blob_content_encoding {
            request.insert_header("x-ms-blob-content-encoding", blob_content_encoding);
        }
        if let Some(blob_content_language) = options.blob_content_language {
            request.insert_header("x-ms-blob-content-language", blob_content_language);
        }
        if let Some(blob_content_md5) = options.blob_content_md5 {
            request.insert_header("x-ms-blob-content-md5", blob_content_md5);
        }
        if let Some(blob_content_type) = options.blob_content_type {
            request.insert_header("x-ms-blob-content-type", blob_content_type);
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        request.insert_header("x-ms-copy-source", copy_source.into());
        if let Some(copy_source_authorization) = options.copy_source_authorization {
            request.insert_header("x-ms-copy-source-authorization", copy_source_authorization);
        }
        if let Some(copy_source_blob_properties) = options.copy_source_blob_properties {
            request.insert_header(
                "x-ms-copy-source-blob-properties",
                copy_source_blob_properties.to_string(),
            );
        }
        if let Some(copy_source_tags) = options.copy_source_tags {
            request.insert_header("x-ms-copy-source-tags", copy_source_tags);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm);
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(source_content_md5) = options.source_content_md5 {
            request.insert_header("x-ms-source-content-md5", source_content_md5);
        }
        if let Some(source_if_match) = options.source_if_match {
            request.insert_header("x-ms-source-if-match", source_if_match);
        }
        if let Some(source_if_modified_since) = options.source_if_modified_since {
            request.insert_header(
                "x-ms-source-if-modified-since",
                source_if_modified_since.to_string(),
            );
        }
        if let Some(source_if_none_match) = options.source_if_none_match {
            request.insert_header("x-ms-source-if-none-match", source_if_none_match);
        }
        if let Some(source_if_tags) = options.source_if_tags {
            request.insert_header("x-ms-source-if-tags", source_if_tags);
        }
        if let Some(blob_tags_string) = options.blob_tags_string {
            request.insert_header("x-ms-tags", blob_tags_string);
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Stage Block operation creates a new block to be committed as part of a blob
    pub async fn stage_block(
        &self,
        body: RequestContent<Vec<u8>>,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        block_id: impl Into<String>,
        content_length: i64,
        version: impl Into<String>,
        options: Option<BlobBlockBlobStageBlockOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}?comp=block");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        url.query_pairs_mut()
            .append_pair("blockid", &block_id.into());
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-length", content_length.to_string());
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", transactional_content_md5);
        }
        request.insert_header("content-type", "application/json");
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(transactional_content_crc64) = options.transactional_content_crc64 {
            request.insert_header("x-ms-content-crc64", transactional_content_crc64);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm);
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-version", version.into());
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Stage Block From URL operation creates a new block to be committed as part of a blob where the contents are read from
    /// a URL.
    pub async fn stage_block_from_url(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        block_id: impl Into<String>,
        content_length: i64,
        source_url: impl Into<String>,
        source_range: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlockBlobStageBlockFromUrlOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/?comp=block&fromURL/{containerName}/{blob}");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        url.query_pairs_mut()
            .append_pair("blockid", &block_id.into());
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("content-length", content_length.to_string());
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(copy_source_authorization) = options.copy_source_authorization {
            request.insert_header("x-ms-copy-source-authorization", copy_source_authorization);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm);
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(source_content_crc64) = options.source_content_crc64 {
            request.insert_header("x-ms-source-content-crc64", source_content_crc64);
        }
        if let Some(source_content_md5) = options.source_content_md5 {
            request.insert_header("x-ms-source-content-md5", source_content_md5);
        }
        if let Some(source_if_match) = options.source_if_match {
            request.insert_header("x-ms-source-if-match", source_if_match);
        }
        if let Some(source_if_modified_since) = options.source_if_modified_since {
            request.insert_header(
                "x-ms-source-if-modified-since",
                source_if_modified_since.to_string(),
            );
        }
        if let Some(source_if_none_match) = options.source_if_none_match {
            request.insert_header("x-ms-source-if-none-match", source_if_none_match);
        }
        if let Some(source_if_unmodified_since) = options.source_if_unmodified_since {
            request.insert_header(
                "x-ms-source-if-unmodified-since",
                source_if_unmodified_since.to_string(),
            );
        }
        request.insert_header("x-ms-source-range", source_range.into());
        request.insert_header("x-ms-source-url", source_url.into());
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Upload Block Blob operation updates the content of an existing block blob. Updating an existing block blob overwrites
    /// any existing metadata on the blob. Partial updates are not supported with Put Blob; the content of the existing blob is
    /// overwritten with the content of the new blob. To perform a partial update of the content of a block blob, use the Put
    /// Block List operation.
    pub async fn upload(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        body: RequestContent<Vec<u8>>,
        version: impl Into<String>,
        options: Option<BlobBlockBlobUploadOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}?BlockBlob");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", transactional_content_md5);
        }
        request.insert_header("content-type", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(tier) = options.tier {
            request.insert_header("x-ms-access-tier", tier.to_string());
        }
        if let Some(blob_cache_control) = options.blob_cache_control {
            request.insert_header("x-ms-blob-cache-control", blob_cache_control);
        }
        if let Some(blob_content_disposition) = options.blob_content_disposition {
            request.insert_header("x-ms-blob-content-disposition", blob_content_disposition);
        }
        if let Some(blob_content_encoding) = options.blob_content_encoding {
            request.insert_header("x-ms-blob-content-encoding", blob_content_encoding);
        }
        if let Some(blob_content_language) = options.blob_content_language {
            request.insert_header("x-ms-blob-content-language", blob_content_language);
        }
        if let Some(blob_content_md5) = options.blob_content_md5 {
            request.insert_header("x-ms-blob-content-md5", blob_content_md5);
        }
        if let Some(blob_content_type) = options.blob_content_type {
            request.insert_header("x-ms-blob-content-type", blob_content_type);
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(transactional_content_crc64) = options.transactional_content_crc64 {
            request.insert_header("x-ms-content-crc64", transactional_content_crc64);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm);
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(immutability_policy_mode) = options.immutability_policy_mode {
            request.insert_header(
                "x-ms-immutability-policy-mode",
                immutability_policy_mode.to_string(),
            );
        }
        if let Some(immutability_policy_expiry) = options.immutability_policy_expiry {
            request.insert_header(
                "x-ms-immutability-policy-until-date",
                immutability_policy_expiry,
            );
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(legal_hold) = options.legal_hold {
            request.insert_header("x-ms-legal-hold", legal_hold.to_string());
        }
        if let Some(blob_tags_string) = options.blob_tags_string {
            request.insert_header("x-ms-tags", blob_tags_string);
        }
        request.insert_header("x-ms-version", version.into());
        request.set_body(body);
        self.pipeline.send(&mut ctx, &mut request).await
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlockBlobCommitBlockListOptions<'a> {
    blob_cache_control: Option<String>,
    blob_content_disposition: Option<String>,
    blob_content_encoding: Option<String>,
    blob_content_language: Option<String>,
    blob_content_md5: Option<String>,
    blob_content_type: Option<String>,
    blob_tags_string: Option<String>,
    encryption_algorithm: Option<String>,
    encryption_key: Option<String>,
    encryption_key_sha256: Option<String>,
    encryption_scope: Option<String>,
    if_match: Option<String>,
    if_modified_since: Option<OffsetDateTime>,
    if_none_match: Option<String>,
    if_tags: Option<String>,
    if_unmodified_since: Option<OffsetDateTime>,
    immutability_policy_expiry: Option<String>,
    immutability_policy_mode: Option<BlobImmutabilityPolicyMode>,
    legal_hold: Option<bool>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    tier: Option<AccessTier>,
    timeout: Option<i32>,
    transactional_content_crc64: Option<String>,
    transactional_content_md5: Option<String>,
}

impl<'a> BlobBlockBlobCommitBlockListOptions<'a> {
    pub fn builder() -> builders::BlobBlockBlobCommitBlockListOptionsBuilder<'a> {
        builders::BlobBlockBlobCommitBlockListOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlockBlobGetBlockListOptions<'a> {
    if_tags: Option<String>,
    lease_id: Option<String>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    snapshot: Option<String>,
}

impl<'a> BlobBlockBlobGetBlockListOptions<'a> {
    pub fn builder() -> builders::BlobBlockBlobGetBlockListOptionsBuilder<'a> {
        builders::BlobBlockBlobGetBlockListOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlockBlobPutBlobFromUrlOptions<'a> {
    blob_cache_control: Option<String>,
    blob_content_disposition: Option<String>,
    blob_content_encoding: Option<String>,
    blob_content_language: Option<String>,
    blob_content_md5: Option<String>,
    blob_content_type: Option<String>,
    blob_tags_string: Option<String>,
    copy_source_authorization: Option<String>,
    copy_source_blob_properties: Option<bool>,
    copy_source_tags: Option<String>,
    encryption_algorithm: Option<String>,
    encryption_key: Option<String>,
    encryption_key_sha256: Option<String>,
    encryption_scope: Option<String>,
    if_match: Option<String>,
    if_modified_since: Option<OffsetDateTime>,
    if_none_match: Option<String>,
    if_tags: Option<String>,
    if_unmodified_since: Option<OffsetDateTime>,
    lease_id: Option<String>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    source_content_md5: Option<String>,
    source_if_match: Option<String>,
    source_if_modified_since: Option<OffsetDateTime>,
    source_if_none_match: Option<String>,
    source_if_tags: Option<String>,
    tier: Option<AccessTier>,
    timeout: Option<i32>,
    transactional_content_md5: Option<String>,
}

impl<'a> BlobBlockBlobPutBlobFromUrlOptions<'a> {
    pub fn builder() -> builders::BlobBlockBlobPutBlobFromUrlOptionsBuilder<'a> {
        builders::BlobBlockBlobPutBlobFromUrlOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlockBlobStageBlockOptions<'a> {
    encryption_algorithm: Option<String>,
    encryption_key: Option<String>,
    encryption_key_sha256: Option<String>,
    encryption_scope: Option<String>,
    lease_id: Option<String>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    timeout: Option<i32>,
    transactional_content_crc64: Option<String>,
    transactional_content_md5: Option<String>,
}

impl<'a> BlobBlockBlobStageBlockOptions<'a> {
    pub fn builder() -> builders::BlobBlockBlobStageBlockOptionsBuilder<'a> {
        builders::BlobBlockBlobStageBlockOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlockBlobStageBlockFromUrlOptions<'a> {
    copy_source_authorization: Option<String>,
    encryption_algorithm: Option<String>,
    encryption_key: Option<String>,
    encryption_key_sha256: Option<String>,
    encryption_scope: Option<String>,
    lease_id: Option<String>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    source_content_crc64: Option<String>,
    source_content_md5: Option<String>,
    source_if_match: Option<String>,
    source_if_modified_since: Option<OffsetDateTime>,
    source_if_none_match: Option<String>,
    source_if_unmodified_since: Option<OffsetDateTime>,
    timeout: Option<i32>,
}

impl<'a> BlobBlockBlobStageBlockFromUrlOptions<'a> {
    pub fn builder() -> builders::BlobBlockBlobStageBlockFromUrlOptionsBuilder<'a> {
        builders::BlobBlockBlobStageBlockFromUrlOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlockBlobUploadOptions<'a> {
    blob_cache_control: Option<String>,
    blob_content_disposition: Option<String>,
    blob_content_encoding: Option<String>,
    blob_content_language: Option<String>,
    blob_content_md5: Option<String>,
    blob_content_type: Option<String>,
    blob_tags_string: Option<String>,
    encryption_algorithm: Option<String>,
    encryption_key: Option<String>,
    encryption_key_sha256: Option<String>,
    encryption_scope: Option<String>,
    if_match: Option<String>,
    if_modified_since: Option<OffsetDateTime>,
    if_none_match: Option<String>,
    if_tags: Option<String>,
    if_unmodified_since: Option<OffsetDateTime>,
    immutability_policy_expiry: Option<String>,
    immutability_policy_mode: Option<BlobImmutabilityPolicyMode>,
    lease_id: Option<String>,
    legal_hold: Option<bool>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    tier: Option<AccessTier>,
    timeout: Option<i32>,
    transactional_content_crc64: Option<String>,
    transactional_content_md5: Option<String>,
}

impl<'a> BlobBlockBlobUploadOptions<'a> {
    pub fn builder() -> builders::BlobBlockBlobUploadOptionsBuilder<'a> {
        builders::BlobBlockBlobUploadOptionsBuilder::new()
    }
}

pub mod builders {
    use super::*;

    pub struct BlobBlockBlobCommitBlockListOptionsBuilder<'a> {
        options: BlobBlockBlobCommitBlockListOptions<'a>,
    }

    impl BlobBlockBlobCommitBlockListOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlockBlobCommitBlockListOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlockBlobCommitBlockListOptions {
            self.options.clone()
        }

        pub fn with_blob_cache_control(mut self, blob_cache_control: String) -> Self {
            self.options.blob_cache_control = Some(blob_cache_control);
            self
        }

        pub fn with_blob_content_disposition(mut self, blob_content_disposition: String) -> Self {
            self.options.blob_content_disposition = Some(blob_content_disposition);
            self
        }

        pub fn with_blob_content_encoding(mut self, blob_content_encoding: String) -> Self {
            self.options.blob_content_encoding = Some(blob_content_encoding);
            self
        }

        pub fn with_blob_content_language(mut self, blob_content_language: String) -> Self {
            self.options.blob_content_language = Some(blob_content_language);
            self
        }

        pub fn with_blob_content_md5(mut self, blob_content_md5: String) -> Self {
            self.options.blob_content_md5 = Some(blob_content_md5);
            self
        }

        pub fn with_blob_content_type(mut self, blob_content_type: String) -> Self {
            self.options.blob_content_type = Some(blob_content_type);
            self
        }

        pub fn with_blob_tags_string(mut self, blob_tags_string: String) -> Self {
            self.options.blob_tags_string = Some(blob_tags_string);
            self
        }

        pub fn with_encryption_algorithm(mut self, encryption_algorithm: String) -> Self {
            self.options.encryption_algorithm = Some(encryption_algorithm);
            self
        }

        pub fn with_encryption_key(mut self, encryption_key: String) -> Self {
            self.options.encryption_key = Some(encryption_key);
            self
        }

        pub fn with_encryption_key_sha256(mut self, encryption_key_sha256: String) -> Self {
            self.options.encryption_key_sha256 = Some(encryption_key_sha256);
            self
        }

        pub fn with_encryption_scope(mut self, encryption_scope: String) -> Self {
            self.options.encryption_scope = Some(encryption_scope);
            self
        }

        pub fn with_if_match(mut self, if_match: String) -> Self {
            self.options.if_match = Some(if_match);
            self
        }

        pub fn with_if_modified_since(mut self, if_modified_since: OffsetDateTime) -> Self {
            self.options.if_modified_since = Some(if_modified_since);
            self
        }

        pub fn with_if_none_match(mut self, if_none_match: String) -> Self {
            self.options.if_none_match = Some(if_none_match);
            self
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_if_unmodified_since(mut self, if_unmodified_since: OffsetDateTime) -> Self {
            self.options.if_unmodified_since = Some(if_unmodified_since);
            self
        }

        pub fn with_immutability_policy_expiry(
            mut self,
            immutability_policy_expiry: String,
        ) -> Self {
            self.options.immutability_policy_expiry = Some(immutability_policy_expiry);
            self
        }

        pub fn with_immutability_policy_mode(
            mut self,
            immutability_policy_mode: BlobImmutabilityPolicyMode,
        ) -> Self {
            self.options.immutability_policy_mode = Some(immutability_policy_mode);
            self
        }

        pub fn with_legal_hold(mut self, legal_hold: bool) -> Self {
            self.options.legal_hold = Some(legal_hold);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_tier(mut self, tier: AccessTier) -> Self {
            self.options.tier = Some(tier);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }

        pub fn with_transactional_content_crc64(
            mut self,
            transactional_content_crc64: String,
        ) -> Self {
            self.options.transactional_content_crc64 = Some(transactional_content_crc64);
            self
        }

        pub fn with_transactional_content_md5(mut self, transactional_content_md5: String) -> Self {
            self.options.transactional_content_md5 = Some(transactional_content_md5);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlockBlobCommitBlockListOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlockBlobGetBlockListOptionsBuilder<'a> {
        options: BlobBlockBlobGetBlockListOptions<'a>,
    }

    impl BlobBlockBlobGetBlockListOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlockBlobGetBlockListOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlockBlobGetBlockListOptions {
            self.options.clone()
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_lease_id(mut self, lease_id: String) -> Self {
            self.options.lease_id = Some(lease_id);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_snapshot(mut self, snapshot: String) -> Self {
            self.options.snapshot = Some(snapshot);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlockBlobGetBlockListOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlockBlobPutBlobFromUrlOptionsBuilder<'a> {
        options: BlobBlockBlobPutBlobFromUrlOptions<'a>,
    }

    impl BlobBlockBlobPutBlobFromUrlOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlockBlobPutBlobFromUrlOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlockBlobPutBlobFromUrlOptions {
            self.options.clone()
        }

        pub fn with_blob_cache_control(mut self, blob_cache_control: String) -> Self {
            self.options.blob_cache_control = Some(blob_cache_control);
            self
        }

        pub fn with_blob_content_disposition(mut self, blob_content_disposition: String) -> Self {
            self.options.blob_content_disposition = Some(blob_content_disposition);
            self
        }

        pub fn with_blob_content_encoding(mut self, blob_content_encoding: String) -> Self {
            self.options.blob_content_encoding = Some(blob_content_encoding);
            self
        }

        pub fn with_blob_content_language(mut self, blob_content_language: String) -> Self {
            self.options.blob_content_language = Some(blob_content_language);
            self
        }

        pub fn with_blob_content_md5(mut self, blob_content_md5: String) -> Self {
            self.options.blob_content_md5 = Some(blob_content_md5);
            self
        }

        pub fn with_blob_content_type(mut self, blob_content_type: String) -> Self {
            self.options.blob_content_type = Some(blob_content_type);
            self
        }

        pub fn with_blob_tags_string(mut self, blob_tags_string: String) -> Self {
            self.options.blob_tags_string = Some(blob_tags_string);
            self
        }

        pub fn with_copy_source_authorization(mut self, copy_source_authorization: String) -> Self {
            self.options.copy_source_authorization = Some(copy_source_authorization);
            self
        }

        pub fn with_copy_source_blob_properties(
            mut self,
            copy_source_blob_properties: bool,
        ) -> Self {
            self.options.copy_source_blob_properties = Some(copy_source_blob_properties);
            self
        }

        pub fn with_copy_source_tags(mut self, copy_source_tags: String) -> Self {
            self.options.copy_source_tags = Some(copy_source_tags);
            self
        }

        pub fn with_encryption_algorithm(mut self, encryption_algorithm: String) -> Self {
            self.options.encryption_algorithm = Some(encryption_algorithm);
            self
        }

        pub fn with_encryption_key(mut self, encryption_key: String) -> Self {
            self.options.encryption_key = Some(encryption_key);
            self
        }

        pub fn with_encryption_key_sha256(mut self, encryption_key_sha256: String) -> Self {
            self.options.encryption_key_sha256 = Some(encryption_key_sha256);
            self
        }

        pub fn with_encryption_scope(mut self, encryption_scope: String) -> Self {
            self.options.encryption_scope = Some(encryption_scope);
            self
        }

        pub fn with_if_match(mut self, if_match: String) -> Self {
            self.options.if_match = Some(if_match);
            self
        }

        pub fn with_if_modified_since(mut self, if_modified_since: OffsetDateTime) -> Self {
            self.options.if_modified_since = Some(if_modified_since);
            self
        }

        pub fn with_if_none_match(mut self, if_none_match: String) -> Self {
            self.options.if_none_match = Some(if_none_match);
            self
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_if_unmodified_since(mut self, if_unmodified_since: OffsetDateTime) -> Self {
            self.options.if_unmodified_since = Some(if_unmodified_since);
            self
        }

        pub fn with_lease_id(mut self, lease_id: String) -> Self {
            self.options.lease_id = Some(lease_id);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_source_content_md5(mut self, source_content_md5: String) -> Self {
            self.options.source_content_md5 = Some(source_content_md5);
            self
        }

        pub fn with_source_if_match(mut self, source_if_match: String) -> Self {
            self.options.source_if_match = Some(source_if_match);
            self
        }

        pub fn with_source_if_modified_since(
            mut self,
            source_if_modified_since: OffsetDateTime,
        ) -> Self {
            self.options.source_if_modified_since = Some(source_if_modified_since);
            self
        }

        pub fn with_source_if_none_match(mut self, source_if_none_match: String) -> Self {
            self.options.source_if_none_match = Some(source_if_none_match);
            self
        }

        pub fn with_source_if_tags(mut self, source_if_tags: String) -> Self {
            self.options.source_if_tags = Some(source_if_tags);
            self
        }

        pub fn with_tier(mut self, tier: AccessTier) -> Self {
            self.options.tier = Some(tier);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }

        pub fn with_transactional_content_md5(mut self, transactional_content_md5: String) -> Self {
            self.options.transactional_content_md5 = Some(transactional_content_md5);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlockBlobPutBlobFromUrlOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlockBlobStageBlockOptionsBuilder<'a> {
        options: BlobBlockBlobStageBlockOptions<'a>,
    }

    impl BlobBlockBlobStageBlockOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlockBlobStageBlockOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlockBlobStageBlockOptions {
            self.options.clone()
        }

        pub fn with_encryption_algorithm(mut self, encryption_algorithm: String) -> Self {
            self.options.encryption_algorithm = Some(encryption_algorithm);
            self
        }

        pub fn with_encryption_key(mut self, encryption_key: String) -> Self {
            self.options.encryption_key = Some(encryption_key);
            self
        }

        pub fn with_encryption_key_sha256(mut self, encryption_key_sha256: String) -> Self {
            self.options.encryption_key_sha256 = Some(encryption_key_sha256);
            self
        }

        pub fn with_encryption_scope(mut self, encryption_scope: String) -> Self {
            self.options.encryption_scope = Some(encryption_scope);
            self
        }

        pub fn with_lease_id(mut self, lease_id: String) -> Self {
            self.options.lease_id = Some(lease_id);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }

        pub fn with_transactional_content_crc64(
            mut self,
            transactional_content_crc64: String,
        ) -> Self {
            self.options.transactional_content_crc64 = Some(transactional_content_crc64);
            self
        }

        pub fn with_transactional_content_md5(mut self, transactional_content_md5: String) -> Self {
            self.options.transactional_content_md5 = Some(transactional_content_md5);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlockBlobStageBlockOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlockBlobStageBlockFromUrlOptionsBuilder<'a> {
        options: BlobBlockBlobStageBlockFromUrlOptions<'a>,
    }

    impl BlobBlockBlobStageBlockFromUrlOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlockBlobStageBlockFromUrlOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlockBlobStageBlockFromUrlOptions {
            self.options.clone()
        }

        pub fn with_copy_source_authorization(mut self, copy_source_authorization: String) -> Self {
            self.options.copy_source_authorization = Some(copy_source_authorization);
            self
        }

        pub fn with_encryption_algorithm(mut self, encryption_algorithm: String) -> Self {
            self.options.encryption_algorithm = Some(encryption_algorithm);
            self
        }

        pub fn with_encryption_key(mut self, encryption_key: String) -> Self {
            self.options.encryption_key = Some(encryption_key);
            self
        }

        pub fn with_encryption_key_sha256(mut self, encryption_key_sha256: String) -> Self {
            self.options.encryption_key_sha256 = Some(encryption_key_sha256);
            self
        }

        pub fn with_encryption_scope(mut self, encryption_scope: String) -> Self {
            self.options.encryption_scope = Some(encryption_scope);
            self
        }

        pub fn with_lease_id(mut self, lease_id: String) -> Self {
            self.options.lease_id = Some(lease_id);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_source_content_crc64(mut self, source_content_crc64: String) -> Self {
            self.options.source_content_crc64 = Some(source_content_crc64);
            self
        }

        pub fn with_source_content_md5(mut self, source_content_md5: String) -> Self {
            self.options.source_content_md5 = Some(source_content_md5);
            self
        }

        pub fn with_source_if_match(mut self, source_if_match: String) -> Self {
            self.options.source_if_match = Some(source_if_match);
            self
        }

        pub fn with_source_if_modified_since(
            mut self,
            source_if_modified_since: OffsetDateTime,
        ) -> Self {
            self.options.source_if_modified_since = Some(source_if_modified_since);
            self
        }

        pub fn with_source_if_none_match(mut self, source_if_none_match: String) -> Self {
            self.options.source_if_none_match = Some(source_if_none_match);
            self
        }

        pub fn with_source_if_unmodified_since(
            mut self,
            source_if_unmodified_since: OffsetDateTime,
        ) -> Self {
            self.options.source_if_unmodified_since = Some(source_if_unmodified_since);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlockBlobStageBlockFromUrlOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlockBlobUploadOptionsBuilder<'a> {
        options: BlobBlockBlobUploadOptions<'a>,
    }

    impl BlobBlockBlobUploadOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlockBlobUploadOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlockBlobUploadOptions {
            self.options.clone()
        }

        pub fn with_blob_cache_control(mut self, blob_cache_control: String) -> Self {
            self.options.blob_cache_control = Some(blob_cache_control);
            self
        }

        pub fn with_blob_content_disposition(mut self, blob_content_disposition: String) -> Self {
            self.options.blob_content_disposition = Some(blob_content_disposition);
            self
        }

        pub fn with_blob_content_encoding(mut self, blob_content_encoding: String) -> Self {
            self.options.blob_content_encoding = Some(blob_content_encoding);
            self
        }

        pub fn with_blob_content_language(mut self, blob_content_language: String) -> Self {
            self.options.blob_content_language = Some(blob_content_language);
            self
        }

        pub fn with_blob_content_md5(mut self, blob_content_md5: String) -> Self {
            self.options.blob_content_md5 = Some(blob_content_md5);
            self
        }

        pub fn with_blob_content_type(mut self, blob_content_type: String) -> Self {
            self.options.blob_content_type = Some(blob_content_type);
            self
        }

        pub fn with_blob_tags_string(mut self, blob_tags_string: String) -> Self {
            self.options.blob_tags_string = Some(blob_tags_string);
            self
        }

        pub fn with_encryption_algorithm(mut self, encryption_algorithm: String) -> Self {
            self.options.encryption_algorithm = Some(encryption_algorithm);
            self
        }

        pub fn with_encryption_key(mut self, encryption_key: String) -> Self {
            self.options.encryption_key = Some(encryption_key);
            self
        }

        pub fn with_encryption_key_sha256(mut self, encryption_key_sha256: String) -> Self {
            self.options.encryption_key_sha256 = Some(encryption_key_sha256);
            self
        }

        pub fn with_encryption_scope(mut self, encryption_scope: String) -> Self {
            self.options.encryption_scope = Some(encryption_scope);
            self
        }

        pub fn with_if_match(mut self, if_match: String) -> Self {
            self.options.if_match = Some(if_match);
            self
        }

        pub fn with_if_modified_since(mut self, if_modified_since: OffsetDateTime) -> Self {
            self.options.if_modified_since = Some(if_modified_since);
            self
        }

        pub fn with_if_none_match(mut self, if_none_match: String) -> Self {
            self.options.if_none_match = Some(if_none_match);
            self
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_if_unmodified_since(mut self, if_unmodified_since: OffsetDateTime) -> Self {
            self.options.if_unmodified_since = Some(if_unmodified_since);
            self
        }

        pub fn with_immutability_policy_expiry(
            mut self,
            immutability_policy_expiry: String,
        ) -> Self {
            self.options.immutability_policy_expiry = Some(immutability_policy_expiry);
            self
        }

        pub fn with_immutability_policy_mode(
            mut self,
            immutability_policy_mode: BlobImmutabilityPolicyMode,
        ) -> Self {
            self.options.immutability_policy_mode = Some(immutability_policy_mode);
            self
        }

        pub fn with_lease_id(mut self, lease_id: String) -> Self {
            self.options.lease_id = Some(lease_id);
            self
        }

        pub fn with_legal_hold(mut self, legal_hold: bool) -> Self {
            self.options.legal_hold = Some(legal_hold);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_tier(mut self, tier: AccessTier) -> Self {
            self.options.tier = Some(tier);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }

        pub fn with_transactional_content_crc64(
            mut self,
            transactional_content_crc64: String,
        ) -> Self {
            self.options.transactional_content_crc64 = Some(transactional_content_crc64);
            self
        }

        pub fn with_transactional_content_md5(mut self, transactional_content_md5: String) -> Self {
            self.options.transactional_content_md5 = Some(transactional_content_md5);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlockBlobUploadOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }
}
