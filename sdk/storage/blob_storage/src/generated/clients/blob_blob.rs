// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::models::{
    AccessTier, BlobExpiryOptions, BlobImmutabilityPolicyMode, BlobTags, DeleteSnapshotsOptionType,
    QueryRequest, RehydratePriority,
};
use azure_core::builders::ClientMethodOptionsBuilder;
use azure_core::{
    AsClientMethodOptions, ClientMethodOptions, Context, Method, Pipeline, Request, RequestContent,
    Response, Result, Url,
};
use time::OffsetDateTime;

pub struct BlobBlob {
    pub(in crate::generated::clients) endpoint: Url,
    pub(in crate::generated::clients) pipeline: Pipeline,
}

impl BlobBlob {
    /// The Abort Copy From URL operation aborts a pending Copy From URL operation, and leaves a destination blob with zero length
    /// and full metadata.
    pub async fn abort_copy_from_url(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        copy_id: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobAbortCopyFromUrlOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/?comp=copy&copyid");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        request.insert_header("x-ms-copy-id", copy_id.into());
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations.
    pub async fn acquire_lease(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        duration: i32,
        version: impl Into<String>,
        options: Option<BlobBlobAcquireLeaseOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/?comp=lease&acquire");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        request.insert_header("x-ms-lease-duration", duration.to_string());
        if let Some(proposed_lease_id) = options.proposed_lease_id {
            request.insert_header("x-ms-proposed-lease-id", proposed_lease_id);
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations.
    pub async fn break_lease(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobBreakLeaseOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/?comp=lease&break");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(break_period) = options.break_period {
            request.insert_header("x-ms-lease-break-period", break_period.to_string());
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations.
    pub async fn change_lease(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        lease_id: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobChangeLeaseOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/?comp=lease&change");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        request.insert_header("x-ms-lease-id", lease_id.into());
        if let Some(proposed_lease_id) = options.proposed_lease_id {
            request.insert_header("x-ms-proposed-lease-id", proposed_lease_id);
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Copy From URL operation copies a blob or an internet resource to a new blob. It will not return a response until the
    /// copy is complete.
    pub async fn copy_from_url(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        copy_source: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobCopyFromUrlOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/?comp=copy&sync");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(tier) = options.tier {
            request.insert_header("x-ms-access-tier", tier.to_string());
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        request.insert_header("x-ms-copy-source", copy_source.into());
        if let Some(copy_source_authorization) = options.copy_source_authorization {
            request.insert_header("x-ms-copy-source-authorization", copy_source_authorization);
        }
        if let Some(copy_source_tags) = options.copy_source_tags {
            request.insert_header("x-ms-copy-source-tags", copy_source_tags);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(immutability_policy_mode) = options.immutability_policy_mode {
            request.insert_header(
                "x-ms-immutability-policy-mode",
                immutability_policy_mode.to_string(),
            );
        }
        if let Some(immutability_policy_expiry) = options.immutability_policy_expiry {
            request.insert_header(
                "x-ms-immutability-policy-until-date",
                immutability_policy_expiry,
            );
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(legal_hold) = options.legal_hold {
            request.insert_header("x-ms-legal-hold", legal_hold.to_string());
        }
        if let Some(source_content_md5) = options.source_content_md5 {
            request.insert_header("x-ms-source-content-md5", source_content_md5);
        }
        if let Some(source_if_match) = options.source_if_match {
            request.insert_header("x-ms-source-if-match", source_if_match);
        }
        if let Some(source_if_modified_since) = options.source_if_modified_since {
            request.insert_header(
                "x-ms-source-if-modified-since",
                source_if_modified_since.to_string(),
            );
        }
        if let Some(source_if_none_match) = options.source_if_none_match {
            request.insert_header("x-ms-source-if-none-match", source_if_none_match);
        }
        if let Some(source_if_unmodified_since) = options.source_if_unmodified_since {
            request.insert_header(
                "x-ms-source-if-unmodified-since",
                source_if_unmodified_since.to_string(),
            );
        }
        if let Some(blob_tags_string) = options.blob_tags_string {
            request.insert_header("x-ms-tags", blob_tags_string);
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Create Snapshot operation creates a read-only snapshot of a blob
    pub async fn create_snapshot(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobCreateSnapshotOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/?comp=snapshot");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm);
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// If the storage account's soft delete feature is disabled then, when a blob is deleted, it is permanently removed from
    /// the storage account. If the storage account's soft delete feature is enabled, then, when a blob is deleted, it is marked
    /// for deletion and becomes inaccessible immediately. However, the blob service retains the blob or snapshot for the number
    /// of days specified by the DeleteRetentionPolicy section of [Storage service properties] (Set-Blob-Service-Properties.md).
    /// After the specified number of days has passed, the blob's data is permanently removed from the storage account. Note that
    /// you continue to be charged for the soft-deleted blob's storage until it is permanently removed. Use the List Blobs API
    /// and specify the \"include=deleted\" query parameter to discover which blobs and snapshots have been soft deleted. You
    /// can then use the Undelete Blob API to restore a soft-deleted blob. All other operations on a soft-deleted blob or snapshot
    /// causes the service to return an HTTP status code of 404 (ResourceNotFound).
    pub async fn delete(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        version_id: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobDeleteOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(blob_delete_type) = options.blob_delete_type {
            url.query_pairs_mut()
                .append_pair("deletetype", &blob_delete_type.to_string());
        }
        if let Some(snapshot) = options.snapshot {
            url.query_pairs_mut().append_pair("snapshot", &snapshot);
        }
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Delete);
        request.insert_header("accept", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        request.insert_header("versionid", version_id.into());
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(delete_snapshots) = options.delete_snapshots {
            request.insert_header("x-ms-delete-snapshots", delete_snapshots.to_string());
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Delete Immutability Policy operation deletes the immutability policy on the blob.
    pub async fn delete_immutability_policy(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobDeleteImmutabilityPolicyOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/?comp=immutabilityPolicies");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Delete);
        request.insert_header("accept", "application/json");
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Download operation reads or downloads a blob from the system, including its metadata and properties. You can also
    /// call Download to read a snapshot.
    pub async fn download(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        version_id: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobDownloadOptions<'_>>,
    ) -> Result<Response<Vec<u8>>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(snapshot) = options.snapshot {
            url.query_pairs_mut().append_pair("snapshot", &snapshot);
        }
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        request.insert_header("versionid", version_id.into());
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm);
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(range) = options.range {
            request.insert_header("x-ms-range", range);
        }
        if let Some(range_content_crc64) = options.range_content_crc64 {
            request.insert_header(
                "x-ms-range-get-content-crc64",
                range_content_crc64.to_string(),
            );
        }
        if let Some(range_content_md5) = options.range_content_md5 {
            request.insert_header("x-ms-range-get-content-md5", range_content_md5.to_string());
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// Returns the sku name and account kind
    pub async fn get_account_info(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobGetAccountInfoOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/?restype=account&comp=properties");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Get Properties operation returns all user-defined metadata, standard HTTP properties, and system properties for the
    /// blob. It does not return the content of the blob.
    pub async fn get_properties(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        version_id: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobGetPropertiesOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(snapshot) = options.snapshot {
            url.query_pairs_mut().append_pair("snapshot", &snapshot);
        }
        let mut request = Request::new(url, Method::Head);
        request.insert_header("accept", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        request.insert_header("versionid", version_id.into());
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm);
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Get Blob Tags operation enables users to get tags on a blob.
    pub async fn get_tags(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        version_id: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobGetTagsOptions<'_>>,
    ) -> Result<Response<BlobTags>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/{containerName}/{blob}?comp=tags");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(snapshot) = options.snapshot {
            url.query_pairs_mut().append_pair("snapshot", &snapshot);
        }
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Get);
        request.insert_header("accept", "application/json");
        request.insert_header("versionid", version_id.into());
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Query operation enables users to select/project on blob data by providing simple query expressions.
    pub async fn query(
        &self,
        query_request: RequestContent<QueryRequest>,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobQueryOptions<'_>>,
    ) -> Result<Response<Vec<u8>>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/{containerName}/{blob}?comp=query");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(snapshot) = options.snapshot {
            url.query_pairs_mut().append_pair("snapshot", &snapshot);
        }
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        request.insert_header("content-type", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm);
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-version", version.into());
        request.set_body(query_request);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations.
    pub async fn release_lease(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        lease_id: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobReleaseLeaseOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/?comp=lease&release");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        request.insert_header("x-ms-lease-id", lease_id.into());
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// [Update] The Lease Blob operation establishes and manages a lock on a blob for write and delete operations.
    pub async fn renew_lease(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        lease_id: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobRenewLeaseOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/?comp=lease&renew");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        request.insert_header("x-ms-lease-id", lease_id.into());
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// "Set the expiration time of a blob"
    pub async fn set_expiry(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        expiry_options: BlobExpiryOptions,
        expires_on: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobSetExpiryOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/?comp=expiry");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        request.insert_header("x-ms-expiry-option", expiry_options.to_string());
        request.insert_header("x-ms-expiry-time", expires_on.into());
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Set HTTP Headers operation sets system properties on the blob.
    pub async fn set_http_headers(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobSetHttpHeadersOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/?comp=properties&SetHTTPHeaders");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(blob_cache_control) = options.blob_cache_control {
            request.insert_header("x-ms-blob-cache-control", blob_cache_control);
        }
        if let Some(blob_content_disposition) = options.blob_content_disposition {
            request.insert_header("x-ms-blob-content-disposition", blob_content_disposition);
        }
        if let Some(blob_content_encoding) = options.blob_content_encoding {
            request.insert_header("x-ms-blob-content-encoding", blob_content_encoding);
        }
        if let Some(blob_content_language) = options.blob_content_language {
            request.insert_header("x-ms-blob-content-language", blob_content_language);
        }
        if let Some(blob_content_md5) = options.blob_content_md5 {
            request.insert_header("x-ms-blob-content-md5", blob_content_md5);
        }
        if let Some(blob_content_type) = options.blob_content_type {
            request.insert_header("x-ms-blob-content-type", blob_content_type);
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// "Set the immutability policy of a blob"
    pub async fn set_immutability_policy(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobSetImmutabilityPolicyOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/?comp=immutabilityPolicies");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(immutability_policy_mode) = options.immutability_policy_mode {
            request.insert_header(
                "x-ms-immutability-policy-mode",
                immutability_policy_mode.to_string(),
            );
        }
        if let Some(immutability_policy_expiry) = options.immutability_policy_expiry {
            request.insert_header(
                "x-ms-immutability-policy-until-date",
                immutability_policy_expiry,
            );
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Set Legal Hold operation sets a legal hold on the blob.
    pub async fn set_legal_hold(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        legal_hold: bool,
        version: impl Into<String>,
        options: Option<BlobBlobSetLegalHoldOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/?comp=legalhold");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        request.insert_header("x-ms-legal-hold", legal_hold.to_string());
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Set Metadata operation sets user-defined metadata for the specified blob as one or more name-value pairs.
    pub async fn set_metadata(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobSetMetadataOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/?comp=metadata");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(encryption_algorithm) = options.encryption_algorithm {
            request.insert_header("x-ms-encryption-algorithm", encryption_algorithm);
        }
        if let Some(encryption_key) = options.encryption_key {
            request.insert_header("x-ms-encryption-key", encryption_key);
        }
        if let Some(encryption_key_sha256) = options.encryption_key_sha256 {
            request.insert_header("x-ms-encryption-key-sha256", encryption_key_sha256);
        }
        if let Some(encryption_scope) = options.encryption_scope {
            request.insert_header("x-ms-encryption-scope", encryption_scope);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Set Tags operation enables users to set tags on a blob.
    pub async fn set_tags(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        version_id: impl Into<String>,
        tags: RequestContent<BlobTags>,
        version: impl Into<String>,
        options: Option<BlobBlobSetTagsOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/{containerName}/{blob}?comp=tags");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(transactional_content_md5) = options.transactional_content_md5 {
            request.insert_header("content-md5", transactional_content_md5);
        }
        request.insert_header("content-type", "application/json");
        request.insert_header("versionid", version_id.into());
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(transactional_content_crc64) = options.transactional_content_crc64 {
            request.insert_header("x-ms-content-crc64", transactional_content_crc64);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        request.insert_header("x-ms-version", version.into());
        request.set_body(tags);
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Set Tier operation sets the tier on a block blob. The operation is allowed on a page blob or block blob, but not on
    /// an append blob. A block blob's tier determines Hot/Cool/Archive storage type. This operation does not update the blob's
    /// ETag.
    pub async fn set_tier(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        access_tier: AccessTier,
        version: impl Into<String>,
        options: Option<BlobBlobSetTierOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/?comp=tier");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        request.insert_header("x-ms-access-tier", access_tier.to_string());
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(rehydrate_priority) = options.rehydrate_priority {
            request.insert_header("x-ms-rehydrate-priority", rehydrate_priority.to_string());
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// The Start Copy From URL operation copies a blob or an internet resource to a new blob.
    pub async fn start_copy_from_url(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        copy_source: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobStartCopyFromUrlOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/?comp=copy");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        if let Some(timeout) = options.timeout {
            url.query_pairs_mut()
                .append_pair("timeout", &timeout.to_string());
        }
        let mut request = Request::new(url, Method::Put);
        request.insert_header("accept", "application/json");
        if let Some(if_match) = options.if_match {
            request.insert_header("if-match", if_match);
        }
        if let Some(if_modified_since) = options.if_modified_since {
            request.insert_header("if-modified-since", if_modified_since.to_string());
        }
        if let Some(if_none_match) = options.if_none_match {
            request.insert_header("if-none-match", if_none_match);
        }
        if let Some(if_unmodified_since) = options.if_unmodified_since {
            request.insert_header("if-unmodified-since", if_unmodified_since.to_string());
        }
        if let Some(tier) = options.tier {
            request.insert_header("x-ms-access-tier", tier.to_string());
        }
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        request.insert_header("x-ms-copy-source", copy_source.into());
        if let Some(if_tags) = options.if_tags {
            request.insert_header("x-ms-if-tags", if_tags);
        }
        if let Some(immutability_policy_mode) = options.immutability_policy_mode {
            request.insert_header(
                "x-ms-immutability-policy-mode",
                immutability_policy_mode.to_string(),
            );
        }
        if let Some(immutability_policy_expiry) = options.immutability_policy_expiry {
            request.insert_header(
                "x-ms-immutability-policy-until-date",
                immutability_policy_expiry,
            );
        }
        if let Some(lease_id) = options.lease_id {
            request.insert_header("x-ms-lease-id", lease_id);
        }
        if let Some(legal_hold) = options.legal_hold {
            request.insert_header("x-ms-legal-hold", legal_hold.to_string());
        }
        if let Some(rehydrate_priority) = options.rehydrate_priority {
            request.insert_header("x-ms-rehydrate-priority", rehydrate_priority.to_string());
        }
        if let Some(seal_blob) = options.seal_blob {
            request.insert_header("x-ms-seal-blob", seal_blob.to_string());
        }
        if let Some(source_if_match) = options.source_if_match {
            request.insert_header("x-ms-source-if-match", source_if_match);
        }
        if let Some(source_if_modified_since) = options.source_if_modified_since {
            request.insert_header(
                "x-ms-source-if-modified-since",
                source_if_modified_since.to_string(),
            );
        }
        if let Some(source_if_none_match) = options.source_if_none_match {
            request.insert_header("x-ms-source-if-none-match", source_if_none_match);
        }
        if let Some(source_if_tags) = options.source_if_tags {
            request.insert_header("x-ms-source-if-tags", source_if_tags);
        }
        if let Some(source_if_unmodified_since) = options.source_if_unmodified_since {
            request.insert_header(
                "x-ms-source-if-unmodified-since",
                source_if_unmodified_since.to_string(),
            );
        }
        if let Some(blob_tags_string) = options.blob_tags_string {
            request.insert_header("x-ms-tags", blob_tags_string);
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }

    /// "Undelete a blob that was previously soft deleted"
    pub async fn undelete(
        &self,
        container_name: impl Into<String>,
        blob: impl Into<String>,
        version: impl Into<String>,
        options: Option<BlobBlobUndeleteOptions<'_>>,
    ) -> Result<Response<()>> {
        let options = options.unwrap_or_default();
        let mut ctx = options.method_options.context();
        let mut url = self.endpoint.clone();
        let mut path = String::from("/{containerName}/{blob}/?comp=undelete");
        path = path.replace("{blob}", &blob.into());
        path = path.replace("{containerName}", &container_name.into());
        url.set_path(&path);
        let mut request = Request::new(url, Method::Post);
        request.insert_header("accept", "application/json");
        if let Some(request_id) = options.request_id {
            request.insert_header("x-ms-client-request-id", request_id);
        }
        request.insert_header("x-ms-version", version.into());
        self.pipeline.send(&mut ctx, &mut request).await
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobAbortCopyFromUrlOptions<'a> {
    lease_id: Option<String>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobAbortCopyFromUrlOptions<'a> {
    pub fn builder() -> builders::BlobBlobAbortCopyFromUrlOptionsBuilder<'a> {
        builders::BlobBlobAbortCopyFromUrlOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobAcquireLeaseOptions<'a> {
    if_match: Option<String>,
    if_modified_since: Option<OffsetDateTime>,
    if_none_match: Option<String>,
    if_tags: Option<String>,
    if_unmodified_since: Option<OffsetDateTime>,
    method_options: ClientMethodOptions<'a>,
    proposed_lease_id: Option<String>,
    request_id: Option<String>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobAcquireLeaseOptions<'a> {
    pub fn builder() -> builders::BlobBlobAcquireLeaseOptionsBuilder<'a> {
        builders::BlobBlobAcquireLeaseOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobBreakLeaseOptions<'a> {
    break_period: Option<i32>,
    if_match: Option<String>,
    if_modified_since: Option<OffsetDateTime>,
    if_none_match: Option<String>,
    if_tags: Option<String>,
    if_unmodified_since: Option<OffsetDateTime>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobBreakLeaseOptions<'a> {
    pub fn builder() -> builders::BlobBlobBreakLeaseOptionsBuilder<'a> {
        builders::BlobBlobBreakLeaseOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobChangeLeaseOptions<'a> {
    if_match: Option<String>,
    if_modified_since: Option<OffsetDateTime>,
    if_none_match: Option<String>,
    if_tags: Option<String>,
    if_unmodified_since: Option<OffsetDateTime>,
    method_options: ClientMethodOptions<'a>,
    proposed_lease_id: Option<String>,
    request_id: Option<String>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobChangeLeaseOptions<'a> {
    pub fn builder() -> builders::BlobBlobChangeLeaseOptionsBuilder<'a> {
        builders::BlobBlobChangeLeaseOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobCopyFromUrlOptions<'a> {
    blob_tags_string: Option<String>,
    copy_source_authorization: Option<String>,
    copy_source_tags: Option<String>,
    encryption_scope: Option<String>,
    if_match: Option<String>,
    if_modified_since: Option<OffsetDateTime>,
    if_none_match: Option<String>,
    if_tags: Option<String>,
    if_unmodified_since: Option<OffsetDateTime>,
    immutability_policy_expiry: Option<String>,
    immutability_policy_mode: Option<BlobImmutabilityPolicyMode>,
    lease_id: Option<String>,
    legal_hold: Option<bool>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    source_content_md5: Option<String>,
    source_if_match: Option<String>,
    source_if_modified_since: Option<OffsetDateTime>,
    source_if_none_match: Option<String>,
    source_if_unmodified_since: Option<OffsetDateTime>,
    tier: Option<AccessTier>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobCopyFromUrlOptions<'a> {
    pub fn builder() -> builders::BlobBlobCopyFromUrlOptionsBuilder<'a> {
        builders::BlobBlobCopyFromUrlOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobCreateSnapshotOptions<'a> {
    encryption_algorithm: Option<String>,
    encryption_key: Option<String>,
    encryption_key_sha256: Option<String>,
    encryption_scope: Option<String>,
    if_match: Option<String>,
    if_modified_since: Option<OffsetDateTime>,
    if_none_match: Option<String>,
    if_tags: Option<String>,
    if_unmodified_since: Option<OffsetDateTime>,
    lease_id: Option<String>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobCreateSnapshotOptions<'a> {
    pub fn builder() -> builders::BlobBlobCreateSnapshotOptionsBuilder<'a> {
        builders::BlobBlobCreateSnapshotOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobDeleteOptions<'a> {
    blob_delete_type: Option<DeleteSnapshotsOptionType>,
    delete_snapshots: Option<DeleteSnapshotsOptionType>,
    if_match: Option<String>,
    if_modified_since: Option<OffsetDateTime>,
    if_none_match: Option<String>,
    if_tags: Option<String>,
    if_unmodified_since: Option<OffsetDateTime>,
    lease_id: Option<String>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    snapshot: Option<String>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobDeleteOptions<'a> {
    pub fn builder() -> builders::BlobBlobDeleteOptionsBuilder<'a> {
        builders::BlobBlobDeleteOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobDeleteImmutabilityPolicyOptions<'a> {
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobDeleteImmutabilityPolicyOptions<'a> {
    pub fn builder() -> builders::BlobBlobDeleteImmutabilityPolicyOptionsBuilder<'a> {
        builders::BlobBlobDeleteImmutabilityPolicyOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobDownloadOptions<'a> {
    encryption_algorithm: Option<String>,
    encryption_key: Option<String>,
    encryption_key_sha256: Option<String>,
    if_match: Option<String>,
    if_modified_since: Option<OffsetDateTime>,
    if_none_match: Option<String>,
    if_tags: Option<String>,
    if_unmodified_since: Option<OffsetDateTime>,
    lease_id: Option<String>,
    method_options: ClientMethodOptions<'a>,
    range: Option<String>,
    range_content_crc64: Option<bool>,
    range_content_md5: Option<bool>,
    request_id: Option<String>,
    snapshot: Option<String>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobDownloadOptions<'a> {
    pub fn builder() -> builders::BlobBlobDownloadOptionsBuilder<'a> {
        builders::BlobBlobDownloadOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobGetAccountInfoOptions<'a> {
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
}

impl<'a> BlobBlobGetAccountInfoOptions<'a> {
    pub fn builder() -> builders::BlobBlobGetAccountInfoOptionsBuilder<'a> {
        builders::BlobBlobGetAccountInfoOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobGetPropertiesOptions<'a> {
    encryption_algorithm: Option<String>,
    encryption_key: Option<String>,
    encryption_key_sha256: Option<String>,
    if_match: Option<String>,
    if_modified_since: Option<OffsetDateTime>,
    if_none_match: Option<String>,
    if_tags: Option<String>,
    if_unmodified_since: Option<OffsetDateTime>,
    lease_id: Option<String>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    snapshot: Option<String>,
}

impl<'a> BlobBlobGetPropertiesOptions<'a> {
    pub fn builder() -> builders::BlobBlobGetPropertiesOptionsBuilder<'a> {
        builders::BlobBlobGetPropertiesOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobGetTagsOptions<'a> {
    if_tags: Option<String>,
    lease_id: Option<String>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    snapshot: Option<String>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobGetTagsOptions<'a> {
    pub fn builder() -> builders::BlobBlobGetTagsOptionsBuilder<'a> {
        builders::BlobBlobGetTagsOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobQueryOptions<'a> {
    encryption_algorithm: Option<String>,
    encryption_key: Option<String>,
    encryption_key_sha256: Option<String>,
    if_match: Option<String>,
    if_modified_since: Option<OffsetDateTime>,
    if_none_match: Option<String>,
    if_tags: Option<String>,
    if_unmodified_since: Option<OffsetDateTime>,
    lease_id: Option<String>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    snapshot: Option<String>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobQueryOptions<'a> {
    pub fn builder() -> builders::BlobBlobQueryOptionsBuilder<'a> {
        builders::BlobBlobQueryOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobReleaseLeaseOptions<'a> {
    if_match: Option<String>,
    if_modified_since: Option<OffsetDateTime>,
    if_none_match: Option<String>,
    if_tags: Option<String>,
    if_unmodified_since: Option<OffsetDateTime>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobReleaseLeaseOptions<'a> {
    pub fn builder() -> builders::BlobBlobReleaseLeaseOptionsBuilder<'a> {
        builders::BlobBlobReleaseLeaseOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobRenewLeaseOptions<'a> {
    if_match: Option<String>,
    if_modified_since: Option<OffsetDateTime>,
    if_none_match: Option<String>,
    if_tags: Option<String>,
    if_unmodified_since: Option<OffsetDateTime>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobRenewLeaseOptions<'a> {
    pub fn builder() -> builders::BlobBlobRenewLeaseOptionsBuilder<'a> {
        builders::BlobBlobRenewLeaseOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobSetExpiryOptions<'a> {
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
}

impl<'a> BlobBlobSetExpiryOptions<'a> {
    pub fn builder() -> builders::BlobBlobSetExpiryOptionsBuilder<'a> {
        builders::BlobBlobSetExpiryOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobSetHttpHeadersOptions<'a> {
    blob_cache_control: Option<String>,
    blob_content_disposition: Option<String>,
    blob_content_encoding: Option<String>,
    blob_content_language: Option<String>,
    blob_content_md5: Option<String>,
    blob_content_type: Option<String>,
    if_match: Option<String>,
    if_modified_since: Option<OffsetDateTime>,
    if_none_match: Option<String>,
    if_tags: Option<String>,
    if_unmodified_since: Option<OffsetDateTime>,
    lease_id: Option<String>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobSetHttpHeadersOptions<'a> {
    pub fn builder() -> builders::BlobBlobSetHttpHeadersOptionsBuilder<'a> {
        builders::BlobBlobSetHttpHeadersOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobSetImmutabilityPolicyOptions<'a> {
    if_unmodified_since: Option<OffsetDateTime>,
    immutability_policy_expiry: Option<String>,
    immutability_policy_mode: Option<BlobImmutabilityPolicyMode>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobSetImmutabilityPolicyOptions<'a> {
    pub fn builder() -> builders::BlobBlobSetImmutabilityPolicyOptionsBuilder<'a> {
        builders::BlobBlobSetImmutabilityPolicyOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobSetLegalHoldOptions<'a> {
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobSetLegalHoldOptions<'a> {
    pub fn builder() -> builders::BlobBlobSetLegalHoldOptionsBuilder<'a> {
        builders::BlobBlobSetLegalHoldOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobSetMetadataOptions<'a> {
    encryption_algorithm: Option<String>,
    encryption_key: Option<String>,
    encryption_key_sha256: Option<String>,
    encryption_scope: Option<String>,
    if_match: Option<String>,
    if_modified_since: Option<OffsetDateTime>,
    if_none_match: Option<String>,
    if_tags: Option<String>,
    if_unmodified_since: Option<OffsetDateTime>,
    lease_id: Option<String>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobSetMetadataOptions<'a> {
    pub fn builder() -> builders::BlobBlobSetMetadataOptionsBuilder<'a> {
        builders::BlobBlobSetMetadataOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobSetTagsOptions<'a> {
    if_tags: Option<String>,
    lease_id: Option<String>,
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
    timeout: Option<i32>,
    transactional_content_crc64: Option<String>,
    transactional_content_md5: Option<String>,
}

impl<'a> BlobBlobSetTagsOptions<'a> {
    pub fn builder() -> builders::BlobBlobSetTagsOptionsBuilder<'a> {
        builders::BlobBlobSetTagsOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobSetTierOptions<'a> {
    if_tags: Option<String>,
    lease_id: Option<String>,
    method_options: ClientMethodOptions<'a>,
    rehydrate_priority: Option<RehydratePriority>,
    request_id: Option<String>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobSetTierOptions<'a> {
    pub fn builder() -> builders::BlobBlobSetTierOptionsBuilder<'a> {
        builders::BlobBlobSetTierOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobStartCopyFromUrlOptions<'a> {
    blob_tags_string: Option<String>,
    if_match: Option<String>,
    if_modified_since: Option<OffsetDateTime>,
    if_none_match: Option<String>,
    if_tags: Option<String>,
    if_unmodified_since: Option<OffsetDateTime>,
    immutability_policy_expiry: Option<String>,
    immutability_policy_mode: Option<BlobImmutabilityPolicyMode>,
    lease_id: Option<String>,
    legal_hold: Option<bool>,
    method_options: ClientMethodOptions<'a>,
    rehydrate_priority: Option<RehydratePriority>,
    request_id: Option<String>,
    seal_blob: Option<bool>,
    source_if_match: Option<String>,
    source_if_modified_since: Option<OffsetDateTime>,
    source_if_none_match: Option<String>,
    source_if_tags: Option<String>,
    source_if_unmodified_since: Option<OffsetDateTime>,
    tier: Option<AccessTier>,
    timeout: Option<i32>,
}

impl<'a> BlobBlobStartCopyFromUrlOptions<'a> {
    pub fn builder() -> builders::BlobBlobStartCopyFromUrlOptionsBuilder<'a> {
        builders::BlobBlobStartCopyFromUrlOptionsBuilder::new()
    }
}

#[derive(Clone, Debug, Default)]
pub struct BlobBlobUndeleteOptions<'a> {
    method_options: ClientMethodOptions<'a>,
    request_id: Option<String>,
}

impl<'a> BlobBlobUndeleteOptions<'a> {
    pub fn builder() -> builders::BlobBlobUndeleteOptionsBuilder<'a> {
        builders::BlobBlobUndeleteOptionsBuilder::new()
    }
}

pub mod builders {
    use super::*;

    pub struct BlobBlobAbortCopyFromUrlOptionsBuilder<'a> {
        options: BlobBlobAbortCopyFromUrlOptions<'a>,
    }

    impl BlobBlobAbortCopyFromUrlOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobAbortCopyFromUrlOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobAbortCopyFromUrlOptions {
            self.options.clone()
        }

        pub fn with_lease_id(mut self, lease_id: String) -> Self {
            self.options.lease_id = Some(lease_id);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobAbortCopyFromUrlOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobAcquireLeaseOptionsBuilder<'a> {
        options: BlobBlobAcquireLeaseOptions<'a>,
    }

    impl BlobBlobAcquireLeaseOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobAcquireLeaseOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobAcquireLeaseOptions {
            self.options.clone()
        }

        pub fn with_if_match(mut self, if_match: String) -> Self {
            self.options.if_match = Some(if_match);
            self
        }

        pub fn with_if_modified_since(mut self, if_modified_since: OffsetDateTime) -> Self {
            self.options.if_modified_since = Some(if_modified_since);
            self
        }

        pub fn with_if_none_match(mut self, if_none_match: String) -> Self {
            self.options.if_none_match = Some(if_none_match);
            self
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_if_unmodified_since(mut self, if_unmodified_since: OffsetDateTime) -> Self {
            self.options.if_unmodified_since = Some(if_unmodified_since);
            self
        }

        pub fn with_proposed_lease_id(mut self, proposed_lease_id: String) -> Self {
            self.options.proposed_lease_id = Some(proposed_lease_id);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobAcquireLeaseOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobBreakLeaseOptionsBuilder<'a> {
        options: BlobBlobBreakLeaseOptions<'a>,
    }

    impl BlobBlobBreakLeaseOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobBreakLeaseOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobBreakLeaseOptions {
            self.options.clone()
        }

        pub fn with_break_period(mut self, break_period: i32) -> Self {
            self.options.break_period = Some(break_period);
            self
        }

        pub fn with_if_match(mut self, if_match: String) -> Self {
            self.options.if_match = Some(if_match);
            self
        }

        pub fn with_if_modified_since(mut self, if_modified_since: OffsetDateTime) -> Self {
            self.options.if_modified_since = Some(if_modified_since);
            self
        }

        pub fn with_if_none_match(mut self, if_none_match: String) -> Self {
            self.options.if_none_match = Some(if_none_match);
            self
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_if_unmodified_since(mut self, if_unmodified_since: OffsetDateTime) -> Self {
            self.options.if_unmodified_since = Some(if_unmodified_since);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobBreakLeaseOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobChangeLeaseOptionsBuilder<'a> {
        options: BlobBlobChangeLeaseOptions<'a>,
    }

    impl BlobBlobChangeLeaseOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobChangeLeaseOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobChangeLeaseOptions {
            self.options.clone()
        }

        pub fn with_if_match(mut self, if_match: String) -> Self {
            self.options.if_match = Some(if_match);
            self
        }

        pub fn with_if_modified_since(mut self, if_modified_since: OffsetDateTime) -> Self {
            self.options.if_modified_since = Some(if_modified_since);
            self
        }

        pub fn with_if_none_match(mut self, if_none_match: String) -> Self {
            self.options.if_none_match = Some(if_none_match);
            self
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_if_unmodified_since(mut self, if_unmodified_since: OffsetDateTime) -> Self {
            self.options.if_unmodified_since = Some(if_unmodified_since);
            self
        }

        pub fn with_proposed_lease_id(mut self, proposed_lease_id: String) -> Self {
            self.options.proposed_lease_id = Some(proposed_lease_id);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobChangeLeaseOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobCopyFromUrlOptionsBuilder<'a> {
        options: BlobBlobCopyFromUrlOptions<'a>,
    }

    impl BlobBlobCopyFromUrlOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobCopyFromUrlOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobCopyFromUrlOptions {
            self.options.clone()
        }

        pub fn with_blob_tags_string(mut self, blob_tags_string: String) -> Self {
            self.options.blob_tags_string = Some(blob_tags_string);
            self
        }

        pub fn with_copy_source_authorization(mut self, copy_source_authorization: String) -> Self {
            self.options.copy_source_authorization = Some(copy_source_authorization);
            self
        }

        pub fn with_copy_source_tags(mut self, copy_source_tags: String) -> Self {
            self.options.copy_source_tags = Some(copy_source_tags);
            self
        }

        pub fn with_encryption_scope(mut self, encryption_scope: String) -> Self {
            self.options.encryption_scope = Some(encryption_scope);
            self
        }

        pub fn with_if_match(mut self, if_match: String) -> Self {
            self.options.if_match = Some(if_match);
            self
        }

        pub fn with_if_modified_since(mut self, if_modified_since: OffsetDateTime) -> Self {
            self.options.if_modified_since = Some(if_modified_since);
            self
        }

        pub fn with_if_none_match(mut self, if_none_match: String) -> Self {
            self.options.if_none_match = Some(if_none_match);
            self
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_if_unmodified_since(mut self, if_unmodified_since: OffsetDateTime) -> Self {
            self.options.if_unmodified_since = Some(if_unmodified_since);
            self
        }

        pub fn with_immutability_policy_expiry(
            mut self,
            immutability_policy_expiry: String,
        ) -> Self {
            self.options.immutability_policy_expiry = Some(immutability_policy_expiry);
            self
        }

        pub fn with_immutability_policy_mode(
            mut self,
            immutability_policy_mode: BlobImmutabilityPolicyMode,
        ) -> Self {
            self.options.immutability_policy_mode = Some(immutability_policy_mode);
            self
        }

        pub fn with_lease_id(mut self, lease_id: String) -> Self {
            self.options.lease_id = Some(lease_id);
            self
        }

        pub fn with_legal_hold(mut self, legal_hold: bool) -> Self {
            self.options.legal_hold = Some(legal_hold);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_source_content_md5(mut self, source_content_md5: String) -> Self {
            self.options.source_content_md5 = Some(source_content_md5);
            self
        }

        pub fn with_source_if_match(mut self, source_if_match: String) -> Self {
            self.options.source_if_match = Some(source_if_match);
            self
        }

        pub fn with_source_if_modified_since(
            mut self,
            source_if_modified_since: OffsetDateTime,
        ) -> Self {
            self.options.source_if_modified_since = Some(source_if_modified_since);
            self
        }

        pub fn with_source_if_none_match(mut self, source_if_none_match: String) -> Self {
            self.options.source_if_none_match = Some(source_if_none_match);
            self
        }

        pub fn with_source_if_unmodified_since(
            mut self,
            source_if_unmodified_since: OffsetDateTime,
        ) -> Self {
            self.options.source_if_unmodified_since = Some(source_if_unmodified_since);
            self
        }

        pub fn with_tier(mut self, tier: AccessTier) -> Self {
            self.options.tier = Some(tier);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobCopyFromUrlOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobCreateSnapshotOptionsBuilder<'a> {
        options: BlobBlobCreateSnapshotOptions<'a>,
    }

    impl BlobBlobCreateSnapshotOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobCreateSnapshotOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobCreateSnapshotOptions {
            self.options.clone()
        }

        pub fn with_encryption_algorithm(mut self, encryption_algorithm: String) -> Self {
            self.options.encryption_algorithm = Some(encryption_algorithm);
            self
        }

        pub fn with_encryption_key(mut self, encryption_key: String) -> Self {
            self.options.encryption_key = Some(encryption_key);
            self
        }

        pub fn with_encryption_key_sha256(mut self, encryption_key_sha256: String) -> Self {
            self.options.encryption_key_sha256 = Some(encryption_key_sha256);
            self
        }

        pub fn with_encryption_scope(mut self, encryption_scope: String) -> Self {
            self.options.encryption_scope = Some(encryption_scope);
            self
        }

        pub fn with_if_match(mut self, if_match: String) -> Self {
            self.options.if_match = Some(if_match);
            self
        }

        pub fn with_if_modified_since(mut self, if_modified_since: OffsetDateTime) -> Self {
            self.options.if_modified_since = Some(if_modified_since);
            self
        }

        pub fn with_if_none_match(mut self, if_none_match: String) -> Self {
            self.options.if_none_match = Some(if_none_match);
            self
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_if_unmodified_since(mut self, if_unmodified_since: OffsetDateTime) -> Self {
            self.options.if_unmodified_since = Some(if_unmodified_since);
            self
        }

        pub fn with_lease_id(mut self, lease_id: String) -> Self {
            self.options.lease_id = Some(lease_id);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobCreateSnapshotOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobDeleteOptionsBuilder<'a> {
        options: BlobBlobDeleteOptions<'a>,
    }

    impl BlobBlobDeleteOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobDeleteOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobDeleteOptions {
            self.options.clone()
        }

        pub fn with_blob_delete_type(
            mut self,
            blob_delete_type: DeleteSnapshotsOptionType,
        ) -> Self {
            self.options.blob_delete_type = Some(blob_delete_type);
            self
        }

        pub fn with_delete_snapshots(
            mut self,
            delete_snapshots: DeleteSnapshotsOptionType,
        ) -> Self {
            self.options.delete_snapshots = Some(delete_snapshots);
            self
        }

        pub fn with_if_match(mut self, if_match: String) -> Self {
            self.options.if_match = Some(if_match);
            self
        }

        pub fn with_if_modified_since(mut self, if_modified_since: OffsetDateTime) -> Self {
            self.options.if_modified_since = Some(if_modified_since);
            self
        }

        pub fn with_if_none_match(mut self, if_none_match: String) -> Self {
            self.options.if_none_match = Some(if_none_match);
            self
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_if_unmodified_since(mut self, if_unmodified_since: OffsetDateTime) -> Self {
            self.options.if_unmodified_since = Some(if_unmodified_since);
            self
        }

        pub fn with_lease_id(mut self, lease_id: String) -> Self {
            self.options.lease_id = Some(lease_id);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_snapshot(mut self, snapshot: String) -> Self {
            self.options.snapshot = Some(snapshot);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobDeleteOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobDeleteImmutabilityPolicyOptionsBuilder<'a> {
        options: BlobBlobDeleteImmutabilityPolicyOptions<'a>,
    }

    impl BlobBlobDeleteImmutabilityPolicyOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobDeleteImmutabilityPolicyOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobDeleteImmutabilityPolicyOptions {
            self.options.clone()
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobDeleteImmutabilityPolicyOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobDownloadOptionsBuilder<'a> {
        options: BlobBlobDownloadOptions<'a>,
    }

    impl BlobBlobDownloadOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobDownloadOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobDownloadOptions {
            self.options.clone()
        }

        pub fn with_encryption_algorithm(mut self, encryption_algorithm: String) -> Self {
            self.options.encryption_algorithm = Some(encryption_algorithm);
            self
        }

        pub fn with_encryption_key(mut self, encryption_key: String) -> Self {
            self.options.encryption_key = Some(encryption_key);
            self
        }

        pub fn with_encryption_key_sha256(mut self, encryption_key_sha256: String) -> Self {
            self.options.encryption_key_sha256 = Some(encryption_key_sha256);
            self
        }

        pub fn with_if_match(mut self, if_match: String) -> Self {
            self.options.if_match = Some(if_match);
            self
        }

        pub fn with_if_modified_since(mut self, if_modified_since: OffsetDateTime) -> Self {
            self.options.if_modified_since = Some(if_modified_since);
            self
        }

        pub fn with_if_none_match(mut self, if_none_match: String) -> Self {
            self.options.if_none_match = Some(if_none_match);
            self
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_if_unmodified_since(mut self, if_unmodified_since: OffsetDateTime) -> Self {
            self.options.if_unmodified_since = Some(if_unmodified_since);
            self
        }

        pub fn with_lease_id(mut self, lease_id: String) -> Self {
            self.options.lease_id = Some(lease_id);
            self
        }

        pub fn with_range(mut self, range: String) -> Self {
            self.options.range = Some(range);
            self
        }

        pub fn with_range_content_crc64(mut self, range_content_crc64: bool) -> Self {
            self.options.range_content_crc64 = Some(range_content_crc64);
            self
        }

        pub fn with_range_content_md5(mut self, range_content_md5: bool) -> Self {
            self.options.range_content_md5 = Some(range_content_md5);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_snapshot(mut self, snapshot: String) -> Self {
            self.options.snapshot = Some(snapshot);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobDownloadOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobGetAccountInfoOptionsBuilder<'a> {
        options: BlobBlobGetAccountInfoOptions<'a>,
    }

    impl BlobBlobGetAccountInfoOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobGetAccountInfoOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobGetAccountInfoOptions {
            self.options.clone()
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobGetAccountInfoOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobGetPropertiesOptionsBuilder<'a> {
        options: BlobBlobGetPropertiesOptions<'a>,
    }

    impl BlobBlobGetPropertiesOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobGetPropertiesOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobGetPropertiesOptions {
            self.options.clone()
        }

        pub fn with_encryption_algorithm(mut self, encryption_algorithm: String) -> Self {
            self.options.encryption_algorithm = Some(encryption_algorithm);
            self
        }

        pub fn with_encryption_key(mut self, encryption_key: String) -> Self {
            self.options.encryption_key = Some(encryption_key);
            self
        }

        pub fn with_encryption_key_sha256(mut self, encryption_key_sha256: String) -> Self {
            self.options.encryption_key_sha256 = Some(encryption_key_sha256);
            self
        }

        pub fn with_if_match(mut self, if_match: String) -> Self {
            self.options.if_match = Some(if_match);
            self
        }

        pub fn with_if_modified_since(mut self, if_modified_since: OffsetDateTime) -> Self {
            self.options.if_modified_since = Some(if_modified_since);
            self
        }

        pub fn with_if_none_match(mut self, if_none_match: String) -> Self {
            self.options.if_none_match = Some(if_none_match);
            self
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_if_unmodified_since(mut self, if_unmodified_since: OffsetDateTime) -> Self {
            self.options.if_unmodified_since = Some(if_unmodified_since);
            self
        }

        pub fn with_lease_id(mut self, lease_id: String) -> Self {
            self.options.lease_id = Some(lease_id);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_snapshot(mut self, snapshot: String) -> Self {
            self.options.snapshot = Some(snapshot);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobGetPropertiesOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobGetTagsOptionsBuilder<'a> {
        options: BlobBlobGetTagsOptions<'a>,
    }

    impl BlobBlobGetTagsOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobGetTagsOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobGetTagsOptions {
            self.options.clone()
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_lease_id(mut self, lease_id: String) -> Self {
            self.options.lease_id = Some(lease_id);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_snapshot(mut self, snapshot: String) -> Self {
            self.options.snapshot = Some(snapshot);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobGetTagsOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobQueryOptionsBuilder<'a> {
        options: BlobBlobQueryOptions<'a>,
    }

    impl BlobBlobQueryOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobQueryOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobQueryOptions {
            self.options.clone()
        }

        pub fn with_encryption_algorithm(mut self, encryption_algorithm: String) -> Self {
            self.options.encryption_algorithm = Some(encryption_algorithm);
            self
        }

        pub fn with_encryption_key(mut self, encryption_key: String) -> Self {
            self.options.encryption_key = Some(encryption_key);
            self
        }

        pub fn with_encryption_key_sha256(mut self, encryption_key_sha256: String) -> Self {
            self.options.encryption_key_sha256 = Some(encryption_key_sha256);
            self
        }

        pub fn with_if_match(mut self, if_match: String) -> Self {
            self.options.if_match = Some(if_match);
            self
        }

        pub fn with_if_modified_since(mut self, if_modified_since: OffsetDateTime) -> Self {
            self.options.if_modified_since = Some(if_modified_since);
            self
        }

        pub fn with_if_none_match(mut self, if_none_match: String) -> Self {
            self.options.if_none_match = Some(if_none_match);
            self
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_if_unmodified_since(mut self, if_unmodified_since: OffsetDateTime) -> Self {
            self.options.if_unmodified_since = Some(if_unmodified_since);
            self
        }

        pub fn with_lease_id(mut self, lease_id: String) -> Self {
            self.options.lease_id = Some(lease_id);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_snapshot(mut self, snapshot: String) -> Self {
            self.options.snapshot = Some(snapshot);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobQueryOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobReleaseLeaseOptionsBuilder<'a> {
        options: BlobBlobReleaseLeaseOptions<'a>,
    }

    impl BlobBlobReleaseLeaseOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobReleaseLeaseOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobReleaseLeaseOptions {
            self.options.clone()
        }

        pub fn with_if_match(mut self, if_match: String) -> Self {
            self.options.if_match = Some(if_match);
            self
        }

        pub fn with_if_modified_since(mut self, if_modified_since: OffsetDateTime) -> Self {
            self.options.if_modified_since = Some(if_modified_since);
            self
        }

        pub fn with_if_none_match(mut self, if_none_match: String) -> Self {
            self.options.if_none_match = Some(if_none_match);
            self
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_if_unmodified_since(mut self, if_unmodified_since: OffsetDateTime) -> Self {
            self.options.if_unmodified_since = Some(if_unmodified_since);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobReleaseLeaseOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobRenewLeaseOptionsBuilder<'a> {
        options: BlobBlobRenewLeaseOptions<'a>,
    }

    impl BlobBlobRenewLeaseOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobRenewLeaseOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobRenewLeaseOptions {
            self.options.clone()
        }

        pub fn with_if_match(mut self, if_match: String) -> Self {
            self.options.if_match = Some(if_match);
            self
        }

        pub fn with_if_modified_since(mut self, if_modified_since: OffsetDateTime) -> Self {
            self.options.if_modified_since = Some(if_modified_since);
            self
        }

        pub fn with_if_none_match(mut self, if_none_match: String) -> Self {
            self.options.if_none_match = Some(if_none_match);
            self
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_if_unmodified_since(mut self, if_unmodified_since: OffsetDateTime) -> Self {
            self.options.if_unmodified_since = Some(if_unmodified_since);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobRenewLeaseOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobSetExpiryOptionsBuilder<'a> {
        options: BlobBlobSetExpiryOptions<'a>,
    }

    impl BlobBlobSetExpiryOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobSetExpiryOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobSetExpiryOptions {
            self.options.clone()
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobSetExpiryOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobSetHttpHeadersOptionsBuilder<'a> {
        options: BlobBlobSetHttpHeadersOptions<'a>,
    }

    impl BlobBlobSetHttpHeadersOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobSetHttpHeadersOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobSetHttpHeadersOptions {
            self.options.clone()
        }

        pub fn with_blob_cache_control(mut self, blob_cache_control: String) -> Self {
            self.options.blob_cache_control = Some(blob_cache_control);
            self
        }

        pub fn with_blob_content_disposition(mut self, blob_content_disposition: String) -> Self {
            self.options.blob_content_disposition = Some(blob_content_disposition);
            self
        }

        pub fn with_blob_content_encoding(mut self, blob_content_encoding: String) -> Self {
            self.options.blob_content_encoding = Some(blob_content_encoding);
            self
        }

        pub fn with_blob_content_language(mut self, blob_content_language: String) -> Self {
            self.options.blob_content_language = Some(blob_content_language);
            self
        }

        pub fn with_blob_content_md5(mut self, blob_content_md5: String) -> Self {
            self.options.blob_content_md5 = Some(blob_content_md5);
            self
        }

        pub fn with_blob_content_type(mut self, blob_content_type: String) -> Self {
            self.options.blob_content_type = Some(blob_content_type);
            self
        }

        pub fn with_if_match(mut self, if_match: String) -> Self {
            self.options.if_match = Some(if_match);
            self
        }

        pub fn with_if_modified_since(mut self, if_modified_since: OffsetDateTime) -> Self {
            self.options.if_modified_since = Some(if_modified_since);
            self
        }

        pub fn with_if_none_match(mut self, if_none_match: String) -> Self {
            self.options.if_none_match = Some(if_none_match);
            self
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_if_unmodified_since(mut self, if_unmodified_since: OffsetDateTime) -> Self {
            self.options.if_unmodified_since = Some(if_unmodified_since);
            self
        }

        pub fn with_lease_id(mut self, lease_id: String) -> Self {
            self.options.lease_id = Some(lease_id);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobSetHttpHeadersOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobSetImmutabilityPolicyOptionsBuilder<'a> {
        options: BlobBlobSetImmutabilityPolicyOptions<'a>,
    }

    impl BlobBlobSetImmutabilityPolicyOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobSetImmutabilityPolicyOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobSetImmutabilityPolicyOptions {
            self.options.clone()
        }

        pub fn with_if_unmodified_since(mut self, if_unmodified_since: OffsetDateTime) -> Self {
            self.options.if_unmodified_since = Some(if_unmodified_since);
            self
        }

        pub fn with_immutability_policy_expiry(
            mut self,
            immutability_policy_expiry: String,
        ) -> Self {
            self.options.immutability_policy_expiry = Some(immutability_policy_expiry);
            self
        }

        pub fn with_immutability_policy_mode(
            mut self,
            immutability_policy_mode: BlobImmutabilityPolicyMode,
        ) -> Self {
            self.options.immutability_policy_mode = Some(immutability_policy_mode);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobSetImmutabilityPolicyOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobSetLegalHoldOptionsBuilder<'a> {
        options: BlobBlobSetLegalHoldOptions<'a>,
    }

    impl BlobBlobSetLegalHoldOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobSetLegalHoldOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobSetLegalHoldOptions {
            self.options.clone()
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobSetLegalHoldOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobSetMetadataOptionsBuilder<'a> {
        options: BlobBlobSetMetadataOptions<'a>,
    }

    impl BlobBlobSetMetadataOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobSetMetadataOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobSetMetadataOptions {
            self.options.clone()
        }

        pub fn with_encryption_algorithm(mut self, encryption_algorithm: String) -> Self {
            self.options.encryption_algorithm = Some(encryption_algorithm);
            self
        }

        pub fn with_encryption_key(mut self, encryption_key: String) -> Self {
            self.options.encryption_key = Some(encryption_key);
            self
        }

        pub fn with_encryption_key_sha256(mut self, encryption_key_sha256: String) -> Self {
            self.options.encryption_key_sha256 = Some(encryption_key_sha256);
            self
        }

        pub fn with_encryption_scope(mut self, encryption_scope: String) -> Self {
            self.options.encryption_scope = Some(encryption_scope);
            self
        }

        pub fn with_if_match(mut self, if_match: String) -> Self {
            self.options.if_match = Some(if_match);
            self
        }

        pub fn with_if_modified_since(mut self, if_modified_since: OffsetDateTime) -> Self {
            self.options.if_modified_since = Some(if_modified_since);
            self
        }

        pub fn with_if_none_match(mut self, if_none_match: String) -> Self {
            self.options.if_none_match = Some(if_none_match);
            self
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_if_unmodified_since(mut self, if_unmodified_since: OffsetDateTime) -> Self {
            self.options.if_unmodified_since = Some(if_unmodified_since);
            self
        }

        pub fn with_lease_id(mut self, lease_id: String) -> Self {
            self.options.lease_id = Some(lease_id);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobSetMetadataOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobSetTagsOptionsBuilder<'a> {
        options: BlobBlobSetTagsOptions<'a>,
    }

    impl BlobBlobSetTagsOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobSetTagsOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobSetTagsOptions {
            self.options.clone()
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_lease_id(mut self, lease_id: String) -> Self {
            self.options.lease_id = Some(lease_id);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }

        pub fn with_transactional_content_crc64(
            mut self,
            transactional_content_crc64: String,
        ) -> Self {
            self.options.transactional_content_crc64 = Some(transactional_content_crc64);
            self
        }

        pub fn with_transactional_content_md5(mut self, transactional_content_md5: String) -> Self {
            self.options.transactional_content_md5 = Some(transactional_content_md5);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobSetTagsOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobSetTierOptionsBuilder<'a> {
        options: BlobBlobSetTierOptions<'a>,
    }

    impl BlobBlobSetTierOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobSetTierOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobSetTierOptions {
            self.options.clone()
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_lease_id(mut self, lease_id: String) -> Self {
            self.options.lease_id = Some(lease_id);
            self
        }

        pub fn with_rehydrate_priority(mut self, rehydrate_priority: RehydratePriority) -> Self {
            self.options.rehydrate_priority = Some(rehydrate_priority);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobSetTierOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobStartCopyFromUrlOptionsBuilder<'a> {
        options: BlobBlobStartCopyFromUrlOptions<'a>,
    }

    impl BlobBlobStartCopyFromUrlOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobStartCopyFromUrlOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobStartCopyFromUrlOptions {
            self.options.clone()
        }

        pub fn with_blob_tags_string(mut self, blob_tags_string: String) -> Self {
            self.options.blob_tags_string = Some(blob_tags_string);
            self
        }

        pub fn with_if_match(mut self, if_match: String) -> Self {
            self.options.if_match = Some(if_match);
            self
        }

        pub fn with_if_modified_since(mut self, if_modified_since: OffsetDateTime) -> Self {
            self.options.if_modified_since = Some(if_modified_since);
            self
        }

        pub fn with_if_none_match(mut self, if_none_match: String) -> Self {
            self.options.if_none_match = Some(if_none_match);
            self
        }

        pub fn with_if_tags(mut self, if_tags: String) -> Self {
            self.options.if_tags = Some(if_tags);
            self
        }

        pub fn with_if_unmodified_since(mut self, if_unmodified_since: OffsetDateTime) -> Self {
            self.options.if_unmodified_since = Some(if_unmodified_since);
            self
        }

        pub fn with_immutability_policy_expiry(
            mut self,
            immutability_policy_expiry: String,
        ) -> Self {
            self.options.immutability_policy_expiry = Some(immutability_policy_expiry);
            self
        }

        pub fn with_immutability_policy_mode(
            mut self,
            immutability_policy_mode: BlobImmutabilityPolicyMode,
        ) -> Self {
            self.options.immutability_policy_mode = Some(immutability_policy_mode);
            self
        }

        pub fn with_lease_id(mut self, lease_id: String) -> Self {
            self.options.lease_id = Some(lease_id);
            self
        }

        pub fn with_legal_hold(mut self, legal_hold: bool) -> Self {
            self.options.legal_hold = Some(legal_hold);
            self
        }

        pub fn with_rehydrate_priority(mut self, rehydrate_priority: RehydratePriority) -> Self {
            self.options.rehydrate_priority = Some(rehydrate_priority);
            self
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }

        pub fn with_seal_blob(mut self, seal_blob: bool) -> Self {
            self.options.seal_blob = Some(seal_blob);
            self
        }

        pub fn with_source_if_match(mut self, source_if_match: String) -> Self {
            self.options.source_if_match = Some(source_if_match);
            self
        }

        pub fn with_source_if_modified_since(
            mut self,
            source_if_modified_since: OffsetDateTime,
        ) -> Self {
            self.options.source_if_modified_since = Some(source_if_modified_since);
            self
        }

        pub fn with_source_if_none_match(mut self, source_if_none_match: String) -> Self {
            self.options.source_if_none_match = Some(source_if_none_match);
            self
        }

        pub fn with_source_if_tags(mut self, source_if_tags: String) -> Self {
            self.options.source_if_tags = Some(source_if_tags);
            self
        }

        pub fn with_source_if_unmodified_since(
            mut self,
            source_if_unmodified_since: OffsetDateTime,
        ) -> Self {
            self.options.source_if_unmodified_since = Some(source_if_unmodified_since);
            self
        }

        pub fn with_tier(mut self, tier: AccessTier) -> Self {
            self.options.tier = Some(tier);
            self
        }

        pub fn with_timeout(mut self, timeout: i32) -> Self {
            self.options.timeout = Some(timeout);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobStartCopyFromUrlOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }

    pub struct BlobBlobUndeleteOptionsBuilder<'a> {
        options: BlobBlobUndeleteOptions<'a>,
    }

    impl BlobBlobUndeleteOptionsBuilder<'_> {
        pub(super) fn new() -> Self {
            Self {
                options: BlobBlobUndeleteOptions::default(),
            }
        }

        pub fn build(&self) -> BlobBlobUndeleteOptions {
            self.options.clone()
        }

        pub fn with_request_id(mut self, request_id: String) -> Self {
            self.options.request_id = Some(request_id);
            self
        }
    }

    impl<'a> ClientMethodOptionsBuilder<'a> for BlobBlobUndeleteOptionsBuilder<'a> {
        fn with_context(mut self, context: &'a Context) -> Self {
            self.options.method_options.set_context(context);
            self
        }
    }
}
