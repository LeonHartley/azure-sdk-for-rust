// Copyright (c) Microsoft Corporation. All rights reserved.
//
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) Rust Code Generator. DO NOT EDIT.

use crate::models::{
    AccessTier, ArchiveStatus, BlobImmutabilityPolicyMode, BlobType, CopyStatus,
    GeoReplicationStatus, LeaseDuration, LeaseState, LeaseStatus, PublicAccessType,
    QueryRequestTypeSqlOnly, QueryType, RehydratePriority,
};
use async_std::task::block_on;
use azure_core::{RequestContent, Response};
use serde::{Deserialize, Serialize};
use time::OffsetDateTime;
use typespec_derive::Model;

/// Represents an access policy.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct AccessPolicy {
    /// The date-time the policy expires.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expiry: Option<OffsetDateTime>,

    /// The permissions for acl the policy.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub permission: Option<String>,

    /// The date-time the policy is active.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<OffsetDateTime>,
}

/// Represents the Apache Arrow configuration.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ArrowConfiguration {
    /// The Apache Arrow schema
    #[serde(skip_serializing_if = "Option::is_none")]
    pub schema: Option<Vec<ArrowField>>,
}

/// Represents an Apache Arrow field.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ArrowField {
    /// The arrow field name.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// The arrow field precision.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub precision: Option<i32>,

    /// The arrow field scale.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub scale: Option<i32>,

    /// The arrow field type.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<String>,
}

/// The blob flat list segment.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct BlobFlatListSegment {
    /// The blob items.
    #[serde(rename = "blobItems")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub blob_items: Option<Vec<BlobItemInternal>>,
}

/// Represents an array of blobs.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct BlobHierarchyListSegment {
    /// The blob items
    #[serde(rename = "blobItems")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub blob_items: Option<Vec<BlobItemInternal>>,

    /// The blob prefixes.
    #[serde(rename = "blobPrefixes")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub blob_prefixes: Option<Vec<BlobPrefix>>,
}

/// An Azure Storage Blob
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct BlobItemInternal {
    /// The tags of the blob.
    #[serde(rename = "blobTags")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub blob_tags: Option<Vec<BlobTag>>,

    /// Whether the blob is deleted.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deleted: Option<bool>,

    /// Whether the blog has versions only.
    #[serde(rename = "hasVersionsOnly")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub has_versions_only: Option<bool>,

    /// Whether the blob is the current version.
    #[serde(rename = "isCurrentVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_current_version: Option<bool>,

    /// The metadata of the blob.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<BlobMetadata>,

    /// The name of the blob.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<BlobName>,

    /// The object replication metadata of the blob.
    #[serde(rename = "objectReplicationMetadata")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub object_replication_metadata: Option<ObjectReplicationMetadata>,

    /// The properties of the blob.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<BlobPropertiesInternal>,

    /// The snapshot of the blob.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub snapshot: Option<String>,

    /// The version id of the blob.
    #[serde(rename = "versionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version_id: Option<String>,
}

/// The blob metadata.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct BlobMetadata {
    /// Whether the blob metadata is encrypted.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encrypted: Option<String>,
}

/// Represents a blob name.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct BlobName {
    /// The blob name.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content: Option<String>,

    /// Whether the blob name is encoded.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encoded: Option<bool>,
}

/// Represents a blob prefix.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct BlobPrefix {
    /// The blob name.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<BlobName>,
}

/// The properties of a blob.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct BlobPropertiesInternal {
    /// The access tier of the blob.
    #[serde(rename = "accessTier")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_tier: Option<AccessTier>,

    /// The access tier change time of the blob.
    #[serde(rename = "accessTierChangeTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_tier_change_time: Option<OffsetDateTime>,

    /// Whether the access tier is inferred.
    #[serde(rename = "accessTierInferred")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_tier_inferred: Option<bool>,

    /// The archive status of the blob.
    #[serde(rename = "archiveStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub archive_status: Option<ArchiveStatus>,

    /// The sequence number of the blob.
    #[serde(rename = "blobSequenceNumber")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub blob_sequence_number: Option<i64>,

    /// The blob type.
    #[serde(rename = "blobType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub blob_type: Option<BlobType>,

    /// The cache control of the blob.
    #[serde(rename = "cacheControl")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cache_control: Option<String>,

    /// The content disposition of the blob.
    #[serde(rename = "contentDisposition")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_disposition: Option<String>,

    /// The content encoding of the blob.
    #[serde(rename = "contentEncoding")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_encoding: Option<String>,

    /// The content language of the blob.
    #[serde(rename = "contentLanguage")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_language: Option<String>,

    /// The content length of the blob.
    #[serde(rename = "contentLength")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_length: Option<i64>,

    /// The content MD5 of the blob.
    #[serde(rename = "contentMd5")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_md5: Option<String>,

    /// The content type of the blob.
    #[serde(rename = "contentType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub content_type: Option<String>,

    /// The copy completion time of the blob.
    #[serde(rename = "copyCompletionTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub copy_completion_time: Option<OffsetDateTime>,

    /// The copy ID of the blob.
    #[serde(rename = "copyId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub copy_id: Option<String>,

    /// The copy progress of the blob.
    #[serde(rename = "copyProgress")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub copy_progress: Option<String>,

    /// The copy source of the blob.
    #[serde(rename = "copySource")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub copy_source: Option<String>,

    /// The copy status of the blob.
    #[serde(rename = "copyStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub copy_status: Option<CopyStatus>,

    /// The copy status description of the blob.
    #[serde(rename = "copyStatusDescription")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub copy_status_description: Option<String>,

    /// The date-time the blob was created in RFC1123 format.
    #[serde(rename = "creationTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_time: Option<OffsetDateTime>,

    /// The time the blob was deleted.
    #[serde(rename = "deletedTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deleted_time: Option<OffsetDateTime>,

    /// The name of the desination snapshot.
    #[serde(rename = "destinationSnapshot")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub destination_snapshot: Option<String>,

    /// The blog ETag.
    #[serde(rename = "eTag")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub e_tag: Option<String>,

    /// The encryption scope of the blob.
    #[serde(rename = "encryptionScope")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encryption_scope: Option<String>,

    /// The expire time of the blob.
    #[serde(rename = "expiryTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expiry_time: Option<OffsetDateTime>,

    /// The immutability policy mode of the blob.
    #[serde(rename = "immutabilityPolicyMode")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub immutability_policy_mode: Option<BlobImmutabilityPolicyMode>,

    /// The immutability policy until time of the blob.
    #[serde(rename = "immutabilityPolicyUntilDate")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub immutability_policy_until_date: Option<OffsetDateTime>,

    /// Whether the blog is incremental copy.
    #[serde(rename = "incrementalCopy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub incremental_copy: Option<bool>,

    /// The last access time of the blob.
    #[serde(rename = "lastAccessTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_access_time: Option<OffsetDateTime>,

    /// The date-time the blob was last modified in RFC1123 format.
    #[serde(rename = "lastModified")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified: Option<OffsetDateTime>,

    /// The lease duration of the blob.
    #[serde(rename = "leaseDuration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lease_duration: Option<LeaseDuration>,

    /// The lease state of the blob.
    #[serde(rename = "leaseState")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lease_state: Option<LeaseState>,

    /// The lease status of the blob.
    #[serde(rename = "leaseStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lease_status: Option<LeaseStatus>,

    /// Whether the blob is under legal hold.
    #[serde(rename = "legalHold")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub legal_hold: Option<bool>,

    /// The rehydrate priority of the blob.
    #[serde(rename = "rehydratePriority")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rehydrate_priority: Option<RehydratePriority>,

    /// The remaining retention days of the blob.
    #[serde(rename = "remainingRetentionDays")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remaining_retention_days: Option<i32>,

    /// Whether the blob is sealed.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sealed: Option<bool>,

    /// Whether the blog is encrypted on the server.
    #[serde(rename = "serverEncrypted")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub server_encrypted: Option<bool>,

    /// The number of tags for the blob.
    #[serde(rename = "tagCount")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tag_count: Option<i32>,
}

/// The blob tags.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct BlobTag {
    /// The key of the tag.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub key: Option<String>,

    /// The value of the tag.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

/// Represents blob tags.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct BlobTags {
    /// Represents the blob tags.
    #[serde(rename = "blobTagSet")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub blob_tag_set: Option<Vec<BlobTag>>,
}

/// The Block lookup list.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct BlockLookupList {
    /// The committed blocks
    #[serde(skip_serializing_if = "Option::is_none")]
    pub committed: Option<Vec<String>>,

    /// The latest blocks
    #[serde(skip_serializing_if = "Option::is_none")]
    pub latest: Option<Vec<String>>,

    /// The uncommitted blocks
    #[serde(skip_serializing_if = "Option::is_none")]
    pub uncommitted: Option<Vec<String>>,
}

/// The clear range.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ClearRange {
    /// The end of the byte range.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,

    /// The start of the byte range.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
}

/// An Azure Storage container.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ContainerItem {
    /// Whether the container is deleted.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delete: Option<bool>,

    /// The metadata of the container.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub metadata: Option<ContainerMetadata>,

    /// The name of the container.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// The properties of the container.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub properties: Option<ContainerProperties>,

    /// The version of the container.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// The metadata of a container.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ContainerMetadata {
    /// Whether the metadata is encrypted.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub encrypted: Option<String>,
}

/// The properties of a container.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ContainerProperties {
    /// The date-time the container was created in RFC1123 format.
    #[serde(rename = "creationTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub creation_time: Option<OffsetDateTime>,

    /// The default encryption scope of the container.
    #[serde(rename = "defaultEncryptionScope")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_encryption_scope: Option<String>,

    /// The deleted time of the container.
    #[serde(rename = "deletedTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deleted_time: Option<OffsetDateTime>,

    /// Whether to prevent encryption scope override.
    #[serde(rename = "denyEncryptionScopeOverride")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub deny_encryption_scope_override: Option<bool>,

    /// The ETag of the container.
    #[serde(rename = "eTag")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub e_tag: Option<String>,

    /// Whether it has an immutability policy.
    #[serde(rename = "hasImmutabilityPolicy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub has_immutability_policy: Option<bool>,

    /// The has legal hold status of the container.
    #[serde(rename = "hasLegalHold")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub has_legal_hold: Option<bool>,

    /// Whether immutable storage with versioning is enabled.
    #[serde(rename = "immutableStorageWithVersioningEnabled")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub immutable_storage_with_versioning_enabled: Option<bool>,

    /// The date-time the container was last modified in RFC1123 format.
    #[serde(rename = "lastModified")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_modified: Option<OffsetDateTime>,

    /// The lease duration of the container.
    #[serde(rename = "leaseDuration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lease_duration: Option<LeaseDuration>,

    /// The lease state of the container.
    #[serde(rename = "leaseState")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lease_state: Option<LeaseState>,

    /// The lease status of the container.
    #[serde(rename = "leaseStatus")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub lease_status: Option<LeaseStatus>,

    /// The public access type of the container.
    #[serde(rename = "publicAccess")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub public_access: Option<PublicAccessType>,

    /// The remaining retention days of the container.
    #[serde(rename = "remainingRetentionDays")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub remaining_retention_days: Option<i32>,
}

/// The CORS rule.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct CorsRule {
    /// The allowed headers.
    #[serde(rename = "allowedHeaders")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_headers: Option<String>,

    /// The allowed methods.
    #[serde(rename = "allowedMethods")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_methods: Option<String>,

    /// The allowed origins.
    #[serde(rename = "allowedOrigins")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allowed_origins: Option<String>,

    /// The exposed headers.
    #[serde(rename = "exposedHeaders")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub exposed_headers: Option<String>,

    /// The maximum age in seconds.
    #[serde(rename = "maxAgeInSeconds")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_age_in_seconds: Option<i32>,
}

/// Represents the delimited text configuration.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct DelimitedTextConfiguration {
    /// The string used to separate columns.
    #[serde(rename = "columnSeparator")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub column_separator: Option<String>,

    /// The string used to escape a quote character in a field.
    #[serde(rename = "escapeChar")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub escape_char: Option<String>,

    /// The string used to quote a specific field.
    #[serde(rename = "fieldQuote")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub field_quote: Option<String>,

    /// Represents whether the data has headers.
    #[serde(rename = "headersPresent")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub headers_present: Option<bool>,

    /// The string used to separate records.
    #[serde(rename = "recordSeparator")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub record_separator: Option<String>,
}

/// The filter blob item.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct FilterBlobItem {
    /// The properties of the blob.
    #[serde(rename = "containerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub container_name: Option<String>,

    /// Whether it is the current version of the blob
    #[serde(rename = "isCurrentVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub is_current_version: Option<bool>,

    /// The name of the blob.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option<String>,

    /// The metadata of the blob.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub tags: Option<BlobTags>,

    /// The version ID of the blob.
    #[serde(rename = "versionId")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version_id: Option<String>,
}

/// The result of a Filter Blobs API call
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct FilterBlobSegment {
    /// The blob segment.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub blobs: Option<Vec<FilterBlobItem>>,

    /// The next marker of the blobs.
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,

    /// The service endpoint.
    #[serde(rename = "serviceEndpoint")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_endpoint: Option<String>,

    /// The filter for the blobs.
    #[serde(rename = "where")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub where_prop: Option<String>,
}

/// The geo replication status.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct GeoReplication {
    /// The last sync time.
    #[serde(rename = "lastSyncTime")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub last_sync_time: Option<String>,

    /// The georeplication status.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub status: Option<GeoReplicationStatus>,
}

/// Represents the JSON text configuration.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct JsonTextConfiguration {
    /// The string used to separate records.
    #[serde(rename = "recordSeparator")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub record_separator: Option<String>,
}

/// Key information
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct KeyInfo {
    /// The date-time the key expires.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expiry: Option<String>,

    /// The date-time the key is active.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<String>,
}

/// An enumeration of blobs.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ListBlobsFlatSegmentResponse {
    /// The container name.
    #[serde(rename = "containerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub container_name: Option<String>,

    /// The marker of the blobs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,

    /// The max results of the blobs.
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i32>,

    /// The next marker of the blobs.
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,

    /// The prefix of the blobs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub rrefix: Option<String>,

    /// The blob segment.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub segment: Option<BlobFlatListSegment>,

    /// The service endpoint.
    #[serde(rename = "serviceEndpoint")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_endpoint: Option<String>,
}

/// An enumeration of blobs
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ListBlobsHierarchySegmentResponse {
    /// The container name.
    #[serde(rename = "containerName")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub container_name: Option<String>,

    /// The delimiter of the blobs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delimiter: Option<String>,

    /// The marker of the blobs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,

    /// The max results of the blobs.
    #[serde(rename = "maxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub max_results: Option<i32>,

    /// The next marker of the blobs.
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,

    /// The prefix of the blobs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,

    /// The blob segment.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub segment: Option<BlobHierarchyListSegment>,

    /// The service endpoint.
    #[serde(rename = "serviceEndpoint")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_endpoint: Option<String>,
}

/// The list container segement response
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ListContainersSegmentResponse {
    /// The container segment.
    #[serde(rename = "containerItems")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub container_items: Option<Vec<ContainerItem>>,

    /// The marker of the containers.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marker: Option<String>,

    /// The max results of the containers.
    #[serde(rename = "maxxResults")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub maxx_results: Option<i32>,

    /// The next marker of the containers.
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,

    /// The prefix of the containers.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub prefix: Option<String>,

    /// The service endpoint.
    #[serde(rename = "serviceEndpoint")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_endpoint: Option<String>,
}

/// The logging properties.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct Logging {
    /// Whether delete operation is logged.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delete: Option<bool>,

    /// Whether read operation is logged.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub read: Option<bool>,

    /// The retention policy of the logs.
    #[serde(rename = "retentionPolicy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retention_policy: Option<RetentionPolicy>,

    /// The version of the logging properties.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,

    /// Whether write operation is logged.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub write: Option<bool>,
}

/// The metrics properties.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct Metrics {
    /// Whether it is enabled.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,

    /// Whether to include API in the metrics.
    #[serde(rename = "includeApis")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub include_apis: Option<bool>,

    /// The retention policy of the metrics.
    #[serde(rename = "retentionPolicy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retention_policy: Option<RetentionPolicy>,

    /// The service properties of the metrics.
    #[serde(rename = "serviceProperties")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub service_properties: Option<MetricsServiceProperties>,

    /// The version of the metrics properties.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// The metrics properties.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct MetricsProperties {
    /// Whether to include API in the metrics.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,

    /// The retention policy of the metrics.
    #[serde(rename = "retentionPolicy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub retention_policy: Option<RetentionPolicy>,

    /// The version of the metrics properties.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub version: Option<String>,
}

/// The metrics service properties.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct MetricsServiceProperties {
    /// The hour metrics properties.
    #[serde(rename = "hourMetrics")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hour_metrics: Option<MetricsProperties>,

    /// The minute metrics properties.
    #[serde(rename = "minuteMetrics")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub minute_metrics: Option<MetricsProperties>,
}

/// The object replication metadata.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ObjectReplicationMetadata {}

/// Represents a page list.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct PageList {
    /// The clear ranges.
    #[serde(rename = "clearRange")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub clear_range: Option<Vec<ClearRange>>,

    /// The next marker.
    #[serde(rename = "nextMarker")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub next_marker: Option<String>,

    /// The page ranges.
    #[serde(rename = "pageRange")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub page_range: Option<Vec<PageRange>>,
}

/// The page range.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct PageRange {
    /// The end of the byte range.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub end: Option<i64>,

    /// The start of the byte range.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub start: Option<i64>,
}

/// Represents the Parquet configuration.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct ParquetConfiguration {}

/// The query format settings.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct QueryFormat {
    /// The Apache Arrow configuration.
    #[serde(rename = "arrowConfiguration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arrow_configuration: Option<ArrowConfiguration>,

    /// The delimited text configuration.
    #[serde(rename = "delimitedTextConfiguration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delimited_text_configuration: Option<DelimitedTextConfiguration>,

    /// The JSON text configuration.
    #[serde(rename = "jsonTextConfiguration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub json_text_configuration: Option<JsonTextConfiguration>,

    /// The Parquet configuration.
    #[serde(rename = "parquetConfiguration")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub parquet_configuration: Option<ParquetConfiguration>,

    /// The query type.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub type_prop: Option<QueryType>,
}

/// Groups the set of query request settings.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct QueryRequest {
    /// The query expression in SQL. The maximum size of the query expression is 256KiB.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub expression: Option<String>,

    /// The input serialization settings.
    #[serde(rename = "inputSerialization")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub input_serialization: Option<QuerySerialization>,

    /// The output serialization settings.
    #[serde(rename = "outputSerialization")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub output_serialization: Option<QuerySerialization>,

    /// Required. The type of the provided query expression.
    #[serde(rename = "queryType")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub query_type: Option<QueryRequestTypeSqlOnly>,
}

/// The query serialization settings.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct QuerySerialization {
    /// The query format.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub format: Option<QueryFormat>,
}

/// The retention policy.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct RetentionPolicy {
    /// Whether to allow permanent delete.
    #[serde(rename = "allowPermanentDelete")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub allow_permanent_delete: Option<bool>,

    /// The number of days to retain the logs.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub days: Option<i32>,

    /// Whether to enable the retention policy.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub enabled: Option<bool>,
}

/// The signed identifier.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct SignedIdentifier {
    /// The access policy for the signed identifier.
    #[serde(rename = "accessPolicy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub access_policy: Option<AccessPolicy>,

    /// The unique ID for the signed identifier.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub id: Option<String>,
}

/// The static website properties.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct StaticWebsite {
    /// The error document.
    #[serde(rename = "errorDocument")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub error_document: Option<String>,

    /// The index document.
    #[serde(rename = "indexDocument")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub index_document: Option<String>,
}

/// The error response.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct StorageError {
    /// The error message.
    #[serde(rename = "Message")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option<String>,
}

/// The service properties.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct StorageServiceProperties {
    /// The CORS properties.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cors: Option<Vec<CorsRule>>,

    /// The default service version.
    #[serde(rename = "defaultServiceVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub default_service_version: Option<String>,

    /// The delete retention policy.
    #[serde(rename = "deleteRetentionPolicy")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub delete_retention_policy: Option<RetentionPolicy>,

    /// The hour metrics properties.
    #[serde(rename = "hourMetrics")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub hour_metrics: Option<Metrics>,

    /// The logging properties.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub logging: Option<Logging>,

    /// The minute metrics properties.
    #[serde(rename = "minuteMetrics")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub minute_metrics: Option<Metrics>,

    /// The static website properties.
    #[serde(rename = "staticWebsite")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub static_website: Option<StaticWebsite>,
}

/// Stats for the storage service.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct StorageServiceStats {
    /// The geo replication stats.
    #[serde(rename = "geoReplication")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub geo_replication: Option<GeoReplication>,
}

/// A user delegation key.
#[derive(Clone, Debug, Default, Deserialize, Model, Serialize)]
#[non_exhaustive]
pub struct UserDelegationKey {
    /// The date-time the key expires.
    #[serde(rename = "signedExpiry")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signed_expiry: Option<String>,

    /// The Azure Active Directory object ID in GUID format.
    #[serde(rename = "signedOid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signed_oid: Option<String>,

    /// Abbreviation of the Azure Storage service that accepts the key.
    #[serde(rename = "signedService")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signed_service: Option<String>,

    /// The date-time the key is active.
    #[serde(rename = "signedStart")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signed_start: Option<String>,

    /// The Azure Active Directory tenant ID in GUID format.
    #[serde(rename = "signedTid")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signed_tid: Option<String>,

    /// The service version that created the key.
    #[serde(rename = "signedVersion")]
    #[serde(skip_serializing_if = "Option::is_none")]
    pub signed_version: Option<String>,

    /// The key as a base64 string.
    #[serde(skip_serializing_if = "Option::is_none")]
    pub value: Option<String>,
}

impl TryFrom<BlobTags> for RequestContent<BlobTags> {
    type Error = azure_core::Error;
    fn try_from(value: BlobTags) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Response<BlobTags>> for BlobTags {
    type Error = azure_core::Error;
    fn try_from(value: Response<BlobTags>) -> Result<Self, Self::Error> {
        let f = || value.into_body().json::<BlobTags>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<BlockLookupList> for RequestContent<BlockLookupList> {
    type Error = azure_core::Error;
    fn try_from(value: BlockLookupList) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Response<BlockLookupList>> for BlockLookupList {
    type Error = azure_core::Error;
    fn try_from(value: Response<BlockLookupList>) -> Result<Self, Self::Error> {
        let f = || value.into_body().json::<BlockLookupList>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<Response<FilterBlobSegment>> for FilterBlobSegment {
    type Error = azure_core::Error;
    fn try_from(value: Response<FilterBlobSegment>) -> Result<Self, Self::Error> {
        let f = || value.into_body().json::<FilterBlobSegment>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<KeyInfo> for RequestContent<KeyInfo> {
    type Error = azure_core::Error;
    fn try_from(value: KeyInfo) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Response<ListBlobsFlatSegmentResponse>> for ListBlobsFlatSegmentResponse {
    type Error = azure_core::Error;
    fn try_from(value: Response<ListBlobsFlatSegmentResponse>) -> Result<Self, Self::Error> {
        let f = || value.into_body().json::<ListBlobsFlatSegmentResponse>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<Response<ListBlobsHierarchySegmentResponse>> for ListBlobsHierarchySegmentResponse {
    type Error = azure_core::Error;
    fn try_from(value: Response<ListBlobsHierarchySegmentResponse>) -> Result<Self, Self::Error> {
        let f = || {
            value
                .into_body()
                .json::<ListBlobsHierarchySegmentResponse>()
        };
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<Response<ListContainersSegmentResponse>> for ListContainersSegmentResponse {
    type Error = azure_core::Error;
    fn try_from(value: Response<ListContainersSegmentResponse>) -> Result<Self, Self::Error> {
        let f = || value.into_body().json::<ListContainersSegmentResponse>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<Response<PageList>> for PageList {
    type Error = azure_core::Error;
    fn try_from(value: Response<PageList>) -> Result<Self, Self::Error> {
        let f = || value.into_body().json::<PageList>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<QueryRequest> for RequestContent<QueryRequest> {
    type Error = azure_core::Error;
    fn try_from(value: QueryRequest) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<StorageServiceProperties> for RequestContent<StorageServiceProperties> {
    type Error = azure_core::Error;
    fn try_from(value: StorageServiceProperties) -> Result<Self, Self::Error> {
        Ok(RequestContent::from(serde_json::to_vec(&value)?))
    }
}

impl TryFrom<Response<StorageServiceProperties>> for StorageServiceProperties {
    type Error = azure_core::Error;
    fn try_from(value: Response<StorageServiceProperties>) -> Result<Self, Self::Error> {
        let f = || value.into_body().json::<StorageServiceProperties>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<Response<StorageServiceStats>> for StorageServiceStats {
    type Error = azure_core::Error;
    fn try_from(value: Response<StorageServiceStats>) -> Result<Self, Self::Error> {
        let f = || value.into_body().json::<StorageServiceStats>();
        let r = block_on(f())?;
        Ok(r)
    }
}

impl TryFrom<Response<UserDelegationKey>> for UserDelegationKey {
    type Error = azure_core::Error;
    fn try_from(value: Response<UserDelegationKey>) -> Result<Self, Self::Error> {
        let f = || value.into_body().json::<UserDelegationKey>();
        let r = block_on(f())?;
        Ok(r)
    }
}
